{"version":3,"sources":["webpack:///webpack/bootstrap 19fffa62716f3f979b4a","webpack:///./target/scripts/photonomix.constants.js","webpack:///../nphyx-vectrix/index.js","webpack:///./target/scripts/photonomix.util.js","webpack:///./target/scripts/game/index.js","webpack:///./target/scripts/draw/index.js","webpack:///../nphyx-pxene/src/pxene.assets.js","webpack:///../nphyx-pxene/src/pxene.constants.js","webpack:///../nphyx-pxene/src/pxene.util.js","webpack:///../nphyx-vectrix/src/vectrix.matrices.js","webpack:///../nphyx-vectrix/src/vectrix.vectors.js","webpack:///./target/scripts/game/Photon.js","webpack:///./target/scripts/photonomix.controls.js","webpack:///../nphyx-pxene/src/controls/index.js","webpack:///../nphyx-pxene/src/pxene.display.js","webpack:///../nphyx-pxene/src/pxene.events.js","webpack:///../nphyx-vectrix/src/vectrix.js","webpack:///./target/scripts/draw/sprites.js","webpack:///./target/scripts/game/Mote.js","webpack:///./target/scripts/game/Void.js","webpack:///../nphyx-pxene/index.js","webpack:///../nphyx-pxene/src/controls/KeyMap.js","webpack:///../nphyx-pxene/src/controls/KeyState.js","webpack:///../nphyx-pxene/src/graphics/Atlas.js","webpack:///../nphyx-pxene/src/graphics/BitmapFont.js","webpack:///../nphyx-pxene/src/graphics/CompositeSprite.js","webpack:///../nphyx-pxene/src/graphics/Sprite.js","webpack:///../nphyx-pxene/src/graphics/index.js","webpack:///../nphyx-pxene/src/pxene.BooleanArray.js","webpack:///../nphyx-pxene/src/pxene.CollisionMap.js","webpack:///../nphyx-pxene/src/pxene.ObjectPool.js","webpack:///../nphyx-pxene/src/pxene.assets.mimeTypes.js","webpack:///../nphyx-pxene/src/pxene.display.buffers.js","webpack:///../nphyx-pxene/src/pxene.display.ui.js","webpack:///../nphyx-pxene/src/pxene.display.util.js","webpack:///../nphyx-vectrix/src/vectrix.quaternions.js","webpack:///./target/scripts/draw/bokeh.js","webpack:///./target/scripts/draw/entities.js","webpack:///./target/scripts/draw/ui.js","webpack:///./target/scripts/game/AntiGravitonCluster.js","webpack:///./target/scripts/game/Emitter.js","webpack:///./target/scripts/game/Marker.js","webpack:///./target/scripts/photonomix.bufferPools.js","webpack:///./target/scripts/photonomix.events.js","webpack:///./target/scripts/photonomix.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,qDAAqD;;AAErD;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA,6C;;;;;;;;;;;;AChDA;AACA;;;;;;;;ACDA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,EAAE;AACF,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mCAAmC,sCAAsC;AACzE;AACA,CAAC;;AAED;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA,oBAAoB,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACjXA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,E;;;;;;;ACjOA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;;;AAGA,sBAAsB;AACtB,kBAAkB;AAClB,sBAAsB;AACtB,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACnIA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,YAAY,MAAM;AAClB;AACA,YAAY,MAAM;AAClB;AACA,YAAY,OAAO,iBAAiB,YAAY;AAChD;AACA,YAAY,OAAO;;AAEnB;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,0C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,YAAY;AAC1D,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,0C;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;;;;;;;AClKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AACA,2BAA2B;AAC3B;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACkC;AAClB;AAChB,OAAO,0EAA0E;AACjF,OAAO,8BAA8B;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8D;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,e;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzSA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,eAAe;AACf,kBAAkB;AAClB,gBAAgB;AAChB,iBAAiB;AACjB,WAAW;AACX;;AAEA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,SAAS;AAChB;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC,qCAAqC;AACrC;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC,+BAA+B;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC,sCAAsC;AACtC;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,U;AAC9B;AACA,mBAAmB,aAAa;AAChC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;;AAGD;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,MAAM;AACjB,WAAW,YAAY;AACvB,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,IAAI;AACf,WAAW,IAAI;AACf,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,WAAW,IAAI;AACf,WAAW,YAAY;AACvB,WAAW,IAAI;AACf,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,iCAAiC;AACjC,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,6B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mCAAmC;AACnC,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mCAAmC;AACnC,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mCAAmC;AACnC,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;AC/kBD;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB,yBAAyB;AACzB,iBAAiB;AACjB,uBAAuB;AACvB,gBAAgB;AAChB,yBAAyB;AACzB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B,4BAA4B;;AAE5B;AACA;AACA,+BAA+B;AAC/B;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA,iC;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX,WAAW;AACX,YAAY;AACZ,YAAY;AACZ,aAAa;AACb;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAc,iCAAiC,mD;;;;;;AAAA;AAAA;AAAA;AAC/C;AACA,KAAK,qBAAqB;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA,sC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA,EAAE,iBAAiB;AACnB,EAAE;AACF;AAAA;AAAA;;AAEA;AACA,EAAE,oBAAoB;AACtB,EAAE,oBAAoB;AACtB,EAAE;AACF;AAAA;AAAA;;AAEA;AACA,EAAE;AACF;AAAA;AAAA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,eAAe;AAC7B;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA,2CAA2C,SAAS;AACpD;AACA;AACA,IAAI;AACJ;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;;AAGD;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA,iC;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc;AACd;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,YAAY,aAAa;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;;AAGD;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;;AAGD;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,KAAK;AAChB,YAAY,gBAAgB;AAC5B;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA,8CAA8C;AAC9C,qBAAqB;AACrB;AACA,kBAAkB;AAClB;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C,iDAAiD;AACjD,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB;AACvB,yBAAyB;AACzB,6CAA6C;AAC7C,gDAAgD;AAChD,kDAAkD;AAClD;AACA;AACA,WAAW,IAAI;AACf,WAAW,MAAM;AACjB,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;ACrvBA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,eAAe;AACf;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,WAAW;AACX;AACA,IAAI;AACJ;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C,E;;;;;;;AC7FA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;;;AAGA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sDAAsD;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;;AAEA;AACA,C;;;;;;;;;;;;;;;;AC5EA;AACgB;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,kDAAkD,aAAa;AAC/D,WAAW,OAAO;AAClB,WAAW,OAAO,oBAAoB,eAAe;AACrD,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,aAAa;AAC/C,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,qB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,0C;AACA,sC;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACQ;AACR;AACmB;AACnB,KAAK,SAAS;AACd;;AAEA,cAAc;AACd;AACA;AACA,mBAAmB;AACnB,sBAAsB;AACtB,cAAc;AACd,uBAAuB;AACvB;AACA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC,kBAAkB,iBAAiB;AACnC,kBAAkB,iBAAiB;AACnC,gBAAgB,eAAe;AAC/B,iBAAiB;AACjB;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACxKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACvBD;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;ACXA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACxTA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,WAAW;AACtB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,UAAU;AACxB,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA,cAAc;AACd;AACA,IAAI,EAAE;AACN,YAAY;AACZ;AACA,IAAI,EAAE;AACN,YAAY;AACZ;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,aAAa;AACb;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,eAAe;AACf;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,cAAc;AACd;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,iBAAiB;AACjB;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,kBAAkB;AAClB;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,YAAY;AACZ;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,eAAe;AACf;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,WAAW;AACX;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,cAAc;AACd;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,cAAc;AACd;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,YAAY;AACZ;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,YAAY;AACZ;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,WAAW;AACX;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,WAAW;AACX;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,gBAAgB;AAChB;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,iBAAiB;AACjB;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,WAAW;AACX;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN,iBAAiB;AACjB;AACA,IAAI,EAAE;AACN,iBAAiB;AACjB;AACA,IAAI,EAAE;AACN,gBAAgB;AAChB;AACA,IAAI,EAAE;AACN,gBAAgB;AAChB;AACA,IAAI,EAAE;AACN,WAAW;AACX;AACA,IAAI,EAAE;AACN,aAAa;AACb;AACA,IAAI,EAAE;AACN,aAAa;AACb;AACA,IAAI,EAAE;AACN,YAAY;AACZ;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,IAAI,EAAE;AACN,gBAAgB;AAChB;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iLAAiL;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,0CAA0C;AAC1C;AACA,0CAA0C;AAC1C;AACA,GAAG;AACH;AACA;AACA,4DAA4D;AAC5D;AACA,4DAA4D;AAC5D;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,mCAAmC;AACnC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;ACxuBA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,E;;;;;;;;;;;;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;;ACVR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,iBAAiB;AACjB,mBAAmB;AACnB,iBAAiB;AACjB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO,iDAAiD;AACnE,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA,6C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,IAAI;AACf,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA,EAAE;AACF;;;;;;;;;ACpRA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;AACA;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,YAAY;AAC/C;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wBAAwB;AAC9B,qE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA,EAAE;AACF;;;;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;;ACZR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI;AACf,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;;;;;;;;;AC7EA;AACA;AACA,OAAO,MAAM;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI,gDAAgD,iCAAiC;AAChG,YAAY,a;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,IAAI;AACf,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA,sDAAsD;AACtD;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB,+D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7PA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA,WAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,sBAAsB;AAChC,aAAa,uBAAuB;AACpC,QAAQ;AACR,EAAE;;AAEF;AACA;;;;;;;;;AC9FA;AAAA;AACA;AACA,6DAA6D,mBAAmB;AAChF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA,OAAO,IAAI;AACX;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAA8D;AACvE,UAAU,gEAAgE;AAC1E,EAAE;AACF;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAA8D;AACvE,UAAU,gEAAgE;AAC1E,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ,yBAAyB;AAC7C,+BAA+B,2B;AAC/B,6BAA6B;AAC7B;AACA;AACA,YAAY,QAAQ,yBAAyB;AAC7C,+BAA+B,2B;AAC/B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,Q;AACZ;AACA;AACA,+BAA+B,2B;AAC/B;AACA;AACA;AACA;AACA,YAAY,QAAQ,yBAAyB;AAC7C,+BAA+B,2B;AAC/B,qDAAqD;AACrD;AACA;AACA,gF;AACA;AACA;AACA,CAAC;AAAA;AAAA;;;;;;;;;;;;;;AChGD;AACmB;AACL;AACd;AACA,OAAO,IAAI;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,W;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,WAAW;AACjB;AACA;AACA,yC;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AC3GA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClBA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,0BAA0B;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB,gBAAgB;AACrC,KAAK,gBAAgB,gBAAgB;AACrC,KAAK,gBAAgB,gBAAgB;AACrC,KAAK,gBAAgB;AACrB,EAAE;AACF,yCAAyC,SAAS;AAClD;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,mCAAmC;AACnC,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,yDAAyD;AACzD,WAAW,oBAAoB;AAC/B,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,kDAAkD;AAClD,WAAW,oBAAoB;AAC/B,WAAW,WAAW;AACtB,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;;AAED;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB,WAAW,OAAO;;AAElB,YAAY;AACZ;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wFAAwF;AACxF,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,4DAA4D;AAC5D,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;ACnUD;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;ACtIA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB,iBAAiB;AACjB,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,0DAA0D;AAC1D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,sDAAsD,4DAA4D,wDAAwD,8DAA8D;AACxO;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACxcA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;AClIA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,G;;;;;;;AC9HD;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,CAAC,G;;;;;;;ACzHD;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;AC7BA;;AAEA;AACA;AACA,CAAC;AACD;AACA,4DAA4D;;AAE5D;AACA;AACA;;AAEA;AACA,sEAAsE,4EAA4E;AAClJ;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,IAAI,EAAE;AACN,aAAa;AACb;AACA,IAAI,EAAE;AACN,WAAW;AACX;AACA,IAAI,EAAE;AACN,YAAY;AACZ;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;AChEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA,CAAC,G;;;;;;;ACzBD;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA,uBAAuB,4GAA4G,GAAG,kGAAkG,GAAG,qGAAqG,GAAG,uGAAuG,GAAG,8FAA8F;AAC3hB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","file":"photonomix.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 43);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 19fffa62716f3f979b4a","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar TARGET_FPS = exports.TARGET_FPS = 30;\nvar WEIGHT_PRED_R = exports.WEIGHT_PRED_R = 1.3;\nvar WEIGHT_PRED_G = exports.WEIGHT_PRED_G = 0.7;\nvar WEIGHT_PRED_B = exports.WEIGHT_PRED_B = 1;\nvar START_POP = exports.START_POP = 20;\nvar MOTE_BASE_SIZE = exports.MOTE_BASE_SIZE = 0.015;\nvar MOTE_BASE_ALPHA = exports.MOTE_BASE_ALPHA = 1;\nvar MOTE_BASE_SPEED = exports.MOTE_BASE_SPEED = 0.0005;\nvar MOTE_BASE_SIGHT = exports.MOTE_BASE_SIGHT = 0.15;\nvar PREGNANT_THRESHOLD = exports.PREGNANT_THRESHOLD = 172;\nvar PREGNANT_TIME = exports.PREGNANT_TIME = 30;\nvar DEATH_THRESHOLD = exports.DEATH_THRESHOLD = 18;\nvar GRAVITY = exports.GRAVITY = 6.67408e-8;\nvar GLOBAL_DRAG = exports.GLOBAL_DRAG = 0.1;\nvar PHOTON_BASE_SIZE = exports.PHOTON_BASE_SIZE = 0.015;\nvar PHOTON_LIFETIME = exports.PHOTON_LIFETIME = TARGET_FPS * 10;\nvar MARKER_HIT_LIFETIME = exports.MARKER_HIT_LIFETIME = ~~TARGET_FPS;\nvar MARKER_HIT_SIZE = exports.MARKER_HIT_SIZE = 0.1;\nvar VOID_SIZE = exports.VOID_SIZE = 0.01;\nvar EMITTER_SIZE = exports.EMITTER_SIZE = 0.01;\nvar MAX_MOTES = exports.MAX_MOTES = 300;\nvar MAX_PHOTONS = exports.MAX_PHOTONS = ~~(MAX_MOTES * PREGNANT_THRESHOLD) / 2;\nvar MAX_VOIDS = exports.MAX_VOIDS = 5;\nvar MAX_EMITTERS = exports.MAX_EMITTERS = 5;\nvar MAX_ENTITIES = exports.MAX_ENTITIES = MAX_MOTES + MAX_PHOTONS + MAX_VOIDS + MAX_EMITTERS;\nvar POSITIVE_ENERGY = exports.POSITIVE_ENERGY = 0.01; // chance a dead mote will produce an emitter\nvar NEGATIVE_ENERGY = exports.NEGATIVE_ENERGY = 0.01; // chance a dead mote will produce a void\n\n// general debug switch\nvar DEBUG = exports.DEBUG = false;\n// toggles vector validation in various functions that tend to produce\n// infinite or NaN results; when enabled, vectors are checked and if invalid\n// the function is rerun step by step and logged to identify trouble spots\nvar VALIDATE_VECTORS = exports.VALIDATE_VECTORS = DEBUG || true;\n\nvar type = void 0;\nif (typeof SharedArrayBuffer !== \"undefined\") {\n\t/* global SharedArrayBuffer */\n\ttype = SharedArrayBuffer;\n} else {\n\ttype = ArrayBuffer;\n}\n\nvar BUFFER_TYPE = exports.BUFFER_TYPE = type;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/photonomix.constants.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nexport * from \"./src/vectrix\";\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-vectrix/index.js\n// module id = 1\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.shuffle = exports.rotate = exports.outOfBounds = exports.absVec = exports.avoid = exports.drag = exports.accelerate = exports.gravitate = exports.limitVecMut = exports.dist = exports.validate = exports.twiddleVec = undefined;\nexports.twiddle = twiddle;\nexports.logisticSmooth = logisticSmooth;\nexports.adjRand = adjRand;\nexports.posneg = posneg;\nexports.ratio = ratio;\nexports.rat_vec2 = rat_vec2;\nexports.evenNumber = evenNumber;\n\nvar _vectrix = require(\"../../node_modules/@nphyx/vectrix/src/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomix = require(\"./photonomix.constants\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    magnitude = _vectrix$vectors.magnitude,\n    mut_normalize = _vectrix$vectors.mut_normalize,\n    distance = _vectrix$vectors.distance,\n    mut_times = _vectrix$vectors.mut_times,\n    mut_copy = _vectrix$vectors.mut_copy,\n    mut_clamp = _vectrix$vectors.mut_clamp;\nvar minus = vectrix.matrices.minus;\nvar sqrt = Math.sqrt,\n    abs = Math.abs,\n    E = Math.E,\n    pow = Math.pow,\n    cos = Math.cos,\n    sin = Math.sin,\n    random = Math.random,\n    PI = Math.PI;\n\nvar X = 0,\n    Y = 1;\nvar MIN_F = 1e-11;\nvar MAX_F = 1e+11;\n\n/**\n * Twiddles a value by a small amount to avoid zeroes\n */\nfunction twiddle(x) {\n\treturn x + 1e-11 * posneg();\n}\n\nvar twiddleVec = exports.twiddleVec = function () {\n\tvar i = 0 | 0,\n\t    l = 0 | 0;\n\treturn function twiddleVec(v) {\n\t\tfor (i = 0, l = v.length; i < l; ++i) {\n\t\t\tv[i] = twiddle(v[i]);\n\t\t}\n\t\treturn v;\n\t};\n}();\n\nvar validate = exports.validate = function () {\n\tvar i = void 0,\n\t    l = void 0;\n\treturn function validate(v) {\n\t\tfor (i = 0, l = v.length; i < l; i++) {\n\t\t\tif (isNaN(v[i])) throw new Error(\"NaN vector\");\n\t\t\tif (v[i] === Infinity) throw new Error(\"Infinite vector\");\n\t\t\tif (v[i] === -Infinity) throw new Error(\"-Infinite vector\");\n\t\t}\n\t};\n}();\n\nvar dist = exports.dist = function () {\n\tvar dist_diff = vec2();\n\treturn function dist(a, b) {\n\t\treturn magnitude(minus(a, b, dist_diff));\n\t};\n}();\n\nfunction limit(v) {\n\tvar min_v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\tvar max_v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n\n\tif (abs(v) < abs(min_v)) {\n\t\tif (v < 0) v = -min_v;else v = min_v;\n\t} else if (abs(v) > abs(max_v)) {\n\t\tif (v < 0) v = -max_v;else v = max_v;\n\t}\n\treturn v;\n}\n\nvar limitVecMut = exports.limitVecMut = function () {\n\tvar i = 0 | 0,\n\t    l = 0 | 0;\n\t/**\n  * Limits absolute values of vectors within a range.\n  */\n\treturn function limitVecMut(v) {\n\t\tvar min_v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\tvar max_v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n\n\t\tfor (i = 0, l = v.length; i < l; ++i) {\n\t\t\tv[i] = limit(v[i], min_v, max_v);\n\t\t}\n\t};\n}();\n\n/**\n * Gravitate toward target.\n */\nvar gravitate = exports.gravitate = function () {\n\tvar g_v = vec2();\n\tvar mag = 0.0,\n\t    x = 0.0,\n\t    y = 0.0,\n\t    scale = 0.0;\n\treturn function gravitate(p1, p2, strength, out) {\n\t\tout = out || g_v;\n\t\tminus(p1, p2, out);\n\t\tmag = magnitude(out);\n\t\t// inline normalize for speed, since this happens a lot\n\t\tx = out[0];\n\t\ty = out[1];\n\t\tif (x === 0 && y === 0 || mag === 0) return out;\n\t\tscale = mut_clamp(1 / sqrt(x * x + y * y), MIN_F, MAX_F);\n\t\tstrength = mut_clamp(strength, -MAX_F, MAX_F);\n\t\tout[0] = x * scale;\n\t\tout[1] = y * scale;\n\t\t//mut_normalize(out);\n\t\tmut_times(out, -strength * _photonomix.GRAVITY / (mag * mag));\n\t\tif (_photonomix.VALIDATE_VECTORS) {\n\t\t\ttry {\n\t\t\t\tvalidate(out);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"gravitation error\", e);\n\t\t\t\tconsole.log(strength);\n\t\t\t\tminus(p1, p2, out);\n\t\t\t\tconsole.log(\"minus\", out);\n\t\t\t\tlimitVecMut(out, 0.00001, 10); // put a cap on it to avoid infinite acceleration\n\t\t\t\tconsole.log(\"limit\", out);\n\t\t\t\tmag = magnitude(out);\n\t\t\t\tconsole.log(\"magnitude\", mag);\n\t\t\t\tmut_normalize(out);\n\t\t\t\tconsole.log(\"normalize\", out);\n\t\t\t\tmut_times(out, -strength / (mag * mag));\n\t\t\t\tconsole.log(\"scale\", out);\n\t\t\t\tout.fill(0.0);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t};\n}();\n\n/**\n * Accelerate toward a target.\n */\nvar accelerate = exports.accelerate = function () {\n\tvar v = vec2();\n\tvar scale = 0.0,\n\t    x = 0.0,\n\t    y = 0.0;\n\treturn function accelerate(p1, p2, strength, out) {\n\t\tout = out || v;\n\t\tminus(p1, p2, out);\n\t\tx = out[0];\n\t\ty = out[1];\n\t\tif (x === 0 && y === 0) return out;\n\t\tscale = mut_clamp(1 / sqrt(x * x + y * y), MIN_F, MAX_F);\n\t\tstrength = mut_clamp(strength, -MAX_F, MAX_F);\n\t\t// inline normalize for speed, since this happens a lot\n\t\tout[0] = x * scale;\n\t\tout[1] = y * scale;\n\t\t//mut_normalize(out);\n\t\tmut_times(out, -strength);\n\t\tif (_photonomix.VALIDATE_VECTORS) {\n\t\t\ttry {\n\t\t\t\tvalidate(out);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"acceleration error\", e);\n\t\t\t\tconsole.log(\"strength\", strength);\n\t\t\t\tminus(p1, p2, out);\n\t\t\t\tconsole.log(\"minus\", out);\n\t\t\t\tmut_normalize(out);\n\t\t\t\tconsole.log(\"normalize\", out);\n\t\t\t\tmut_times(out, -strength);\n\t\t\t\tconsole.log(\"scale\", out);\n\t\t\t\tout.fill(0.0);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t};\n}();\n\nvar drag = exports.drag = function () {\n\tvar delta = vec2(),\n\t    dragStrength = 0.0,\n\t    dragSpeed = 0.0;\n\tvar scale = 0.0,\n\t    x = 0.0,\n\t    y = 0.0;\n\t/**\n  * Apply drag.\n  */\n\treturn function drag(vel, c, out) {\n\t\tout = out || delta;\n\t\tdragSpeed = magnitude(vel);\n\t\t// null small values\n\t\tdragSpeed = limit(dragSpeed, 0, 1e+11); // avoid infinite dragSpeeds\n\t\tdragStrength = mut_clamp(c * dragSpeed * dragSpeed, 1e-11, 1e+11);\n\t\tmut_copy(out, vel);\n\t\tx = out[0];\n\t\ty = out[1];\n\t\tif (x === 0 && y === 0 || dragStrength === 0) return out;\n\t\t// inline normalize for speed, since this happens a lot\n\t\tscale = mut_clamp(1 / sqrt(x * x + y * y), MIN_F, MAX_F);\n\t\tdragStrength = mut_clamp(dragStrength, MIN_F, MAX_F);\n\t\tout[0] = x * scale;\n\t\tout[1] = y * scale;\n\t\t// mut_normalize(out)\n\t\tmut_times(out, -1);\n\t\tmut_times(out, dragStrength);\n\t\tif (_photonomix.VALIDATE_VECTORS) {\n\t\t\ttry {\n\t\t\t\tvalidate(out);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"drag error\", e);\n\t\t\t\tconsole.log(c, dragSpeed, dragStrength);\n\t\t\t\tconsole.log(\"magnitude\", magnitude(vel));\n\t\t\t\tmut_copy(out, vel);\n\t\t\t\tconsole.log(\"copied\", out);\n\t\t\t\tmut_normalize(out);\n\t\t\t\tconsole.log(\"normalized\", out);\n\t\t\t\tmut_times(out, -1);\n\t\t\t\tconsole.log(\"inverted\", out);\n\t\t\t\tmut_times(out, dragStrength);\n\t\t\t\tconsole.log(\"scaled\", out);\n\t\t\t\tout.fill(0.0);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t};\n}();\n\nvar avoid = exports.avoid = function () {\n\tvar aev = vec2(),\n\t    dist = 0.0;\n\treturn function avoid(vel, pos, opposite, maxDist, speed, out) {\n\t\tdist = distance(pos, opposite) * maxDist;\n\t\tout = out || aev;\n\t\tout[0] = 0.0;\n\t\tout[1] = 0.0;\n\t\tif (dist > 1) {\n\t\t\taccelerate(pos, opposite, speed * dist * dist, out);\n\t\t}\n\t\treturn out;\n\t};\n}();\n\n/**\n * absolute value of vector\n */\nvar absVec = exports.absVec = function () {\n\tvar i = 0 | 0,\n\t    l = 0 | 0;\n\treturn function absVec(v) {\n\t\tfor (i = 0, l = v.length; i < l; ++i) {\n\t\t\tv[i] = abs(v[i]);\n\t\t}\n\t\treturn v;\n\t};\n}();\n\nvar outOfBounds = exports.outOfBounds = function () {\n\treturn function outOfBounds(v, n) {\n\t\tvar x = v[0];\n\t\tvar y = v[1];\n\t\tif (x > n || x < -n) return true;else if (y > n || y < -n) return true;else return false;\n\t};\n}();\n\n/**\n * Smoothing using a sigmoid (logistic function) curve.\n * @param {float} x input value\n * @param {float} x0 midpoint of curve\n * @param {float} L limit of curve\n * @param {float} k slope of curve\n */\nfunction logisticSmooth(x, x0) {\n\tvar L = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x * 2;\n\tvar k = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n\treturn L / (1 + pow(E, k * x - x0));\n}\n\n/**\n * A random function adjusted to a range of -1 to 1 and multiplied by a\n * scaling value\n */\nfunction adjRand() {\n\tvar scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n\treturn (random() * 2 - 1) * scale;\n}\n\n/**\n * Returns a delta velocity vector of the vector p rotated around center point c by\n * r radians.\n */\nvar rotate = exports.rotate = function () {\n\tvar cosr = 0.0,\n\t    sinr = 0.0,\n\t    rdx = 0.0,\n\t    rdy = 0.0,\n\t    rvec = vec2(),\n\t    rdelta = vec2();\n\treturn function rotate(p, c, r, out) {\n\t\tout = out || rvec;\n\t\tcosr = cos(r * PI);\n\t\tsinr = sin(r * PI);\n\t\tminus(p, c, rdelta);\n\t\trdx = rdelta[X];\n\t\trdy = rdelta[Y];\n\t\tout[X] = rdx * cosr - rdy * sinr;\n\t\tout[Y] = rdx * sinr + rdy * cosr;\n\t\treturn out;\n\t};\n}();\n\nfunction posneg() {\n\treturn random() > 0.5 ? 1 : -1;\n}\n/*\nexport function clamp(v, minv, maxv) {\n\treturn max(min(v, maxv), minv);\n}\n*/\n\nfunction ratio(a, b) {\n\treturn a / (abs(a) + abs(b));\n}\nfunction rat_vec2(v) {\n\treturn ratio(v[X], v[Y]);\n}\n\n/**\n* Shuffles array in place. ES6 version\n* @param {Array} a items The array containing the items.\n*/\nvar shuffle = exports.shuffle = function () {\n\tvar i = 0 | 0,\n\t    j = 0 | 0;\n\treturn function shuffle(a) {\n\t\tfor (i = a.length; i; i--) {\n\t\t\tj = Math.floor(Math.random() * i);\n\t\t\tvar _ref = [a[j], a[i - 1]];\n\t\t\ta[i - 1] = _ref[0];\n\t\t\ta[j] = _ref[1];\n\t\t}\n\t};\n}();\n\n/**\n * Round to nearest even number.\n */\nfunction evenNumber(n) {\n\treturn n >> 1 << 1;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/photonomix.util.js\n// module id = 2\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.AntiGravitonCluster = exports.Photon = exports.Marker = exports.Emitter = exports.Void = exports.Mote = undefined;\nexports.Game = Game;\n\nvar _Mote = require(\"./Mote\");\n\nvar _Mote2 = _interopRequireDefault(_Mote);\n\nvar _Void = require(\"./Void\");\n\nvar _Void2 = _interopRequireDefault(_Void);\n\nvar _Emitter = require(\"./Emitter\");\n\nvar _Emitter2 = _interopRequireDefault(_Emitter);\n\nvar _Marker = require(\"./Marker\");\n\nvar _Marker2 = _interopRequireDefault(_Marker);\n\nvar _Photon = require(\"./Photon\");\n\nvar _Photon2 = _interopRequireDefault(_Photon);\n\nvar _AntiGravitonCluster = require(\"./AntiGravitonCluster\");\n\nvar _AntiGravitonCluster2 = _interopRequireDefault(_AntiGravitonCluster);\n\nvar _photonomix = require(\"../photonomix.util\");\n\nvar _photonomix2 = require(\"../photonomix.bufferPools\");\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomix3 = require(\"../photonomix.constants\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Mote = _Mote2.default;\nexports.Void = _Void2.default;\nexports.Emitter = _Emitter2.default;\nexports.Marker = _Marker2.default;\nexports.Photon = _Photon2.default;\nexports.AntiGravitonCluster = _AntiGravitonCluster2.default;\nvar minus = vectrix.matrices.minus;\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    mut_copy = _vectrix$vectors.mut_copy;\n\nvar marks = new Uint16Array(_photonomix3.MAX_MOTES + _photonomix3.MAX_PHOTONS + 100);\nvar random = Math.random;\n\nvar markpos = 0;\nvar mark = 0;\n\nfunction Game() {\n\tthis.entities = [];\n\tthis.photonBuffer = null;\n\tthis.stats = {\n\t\tpop: 0,\n\t\tborn: 0,\n\t\tdied: 0,\n\t\ttarget: 0\n\t};\n\tthis.actions = {};\n\tthis.registerActions();\n\tthis.started = false;\n\treturn this;\n}\n\nGame.prototype.start = function () {\n\tthis.motePool = new _photonomix2.BufferPool(_Mote.BUFFER_LENGTH, _photonomix3.MAX_MOTES);\n\tthis.photonPool = new _photonomix2.BufferPool(_Photon.BUFFER_LENGTH, _photonomix3.MAX_PHOTONS);\n\tfor (var i = 0; i < _photonomix3.START_POP; ++i) {\n\t\tthis.entities.push(new _Mote2.default.random(this.motePool));\n\t}\n\tthis.started = true;\n};\n\nGame.prototype.tick = function () {\n\tvar entities = void 0,\n\t    entity = void 0,\n\t    i = 0 | 0,\n\t    len = 0 | 0,\n\t    tick_delta = 0.0;\n\treturn function tick(timing) {\n\t\tvar delta = timing.interval / timing.elapsed;\n\t\tvar frameCount = timing.frameCount;\n\t\tentities = this.entities;\n\t\tthis.stats.target = 0;\n\t\tthis.stats.pop = 0;\n\t\ttick_delta = delta / _photonomix3.TARGET_FPS;\n\t\tfor (i = 0, len = entities.length; i < len; ++i) {\n\t\t\tentity = entities[i];\n\t\t\tentity.tick(this.entities, tick_delta, frameCount);\n\t\t\t// do mote-specific stuff\n\t\t\tif (entity instanceof _Mote2.default) {\n\t\t\t\tthis.stats.pop++;\n\t\t\t\tif (entity.target) this.stats.target++;\n\t\t\t\tif (entity.injured) {\n\t\t\t\t\tif (frameCount % ~~(_photonomix3.TARGET_FPS * 0.1) === 0) {\n\t\t\t\t\t\tthis.entities.push(entity.bleed(this.photonPool));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// mark dead for removal\n\t\t\t\tif (entity.dying === _photonomix3.DEATH_THRESHOLD) {\n\t\t\t\t\tthis.killMote(entity);\n\t\t\t\t\tmarks[markpos] = i;\n\t\t\t\t\tthis.stats.died++;\n\t\t\t\t\tmarkpos++;\n\t\t\t\t} else if (entity.pregnant === _photonomix3.PREGNANT_TIME) {\n\t\t\t\t\tthis.entities.push(entity.split());\n\t\t\t\t\tthis.stats.born++;\n\t\t\t\t}\n\t\t\t} else if (entity instanceof _Photon2.default || entity instanceof _Marker2.default) {\n\t\t\t\tif (entity.lifetime <= 0) {\n\t\t\t\t\tmarks[markpos] = i;\n\t\t\t\t\tmarkpos++;\n\t\t\t\t}\n\t\t\t} else if (entity.mass <= 0) {\n\t\t\t\tmarks[markpos] = i;\n\t\t\t\tmarkpos++;\n\t\t\t}\n\t\t\t// physics effects sometimes chuck things way out of bounds\n\t\t\t// just delete them, they ain't comin' back\n\t\t\tif ((0, _photonomix.outOfBounds)(entity.pos, 20)) {\n\t\t\t\tmarks[markpos] = i;\n\t\t\t\tmarkpos++;\n\t\t\t}\n\t\t}\n\n\t\t// sweep dead\n\t\twhile (markpos > 0) {\n\t\t\tmarkpos--;\n\t\t\tmark = marks[markpos];\n\t\t\tentity = entities[mark];\n\t\t\tif (entity && entity.pool !== undefined) {\n\t\t\t\tentity.destroy();\n\t\t\t}\n\t\t\tentities.splice(mark, 1);\n\t\t\tmarks[markpos] = 0;\n\t\t}\n\n\t\t// shuffling helps action lock issues and reduces first in list advantage\n\t\t//shuffle(entities);\n\t};\n}();\n\nGame.prototype.emitPhoton = function () {\n\tvar pos = vec2(),\n\t    vel = vec2(),\n\t    center = vec2(),\n\t    p_c = 0,\n\t    base_vel = vec2(0.05, 0.05);\n\treturn function emitPhoton(ipos, ivel, color) {\n\t\tvar count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : p_c;\n\t\tvar max = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 12;\n\n\t\tipos = ipos || [random() * 1.8 - 0.9, random() * 1.8 - 0.9];\n\t\tif (ivel) {\n\t\t\tmut_copy(vel, ivel);\n\t\t} else {\n\t\t\tmut_copy(vel, base_vel);\n\t\t\t(0, _photonomix.rotate)(vel, center, p_c % max / (max / 2), vel);\n\t\t}\n\t\tcolor = color || ~~(random() * 3);\n\t\tmut_copy(pos, ipos);\n\t\tthis.entities.push(new _Photon2.default(pos, vel, color, this.photonPool));\n\t\tp_c++;\n\t\treturn color;\n\t};\n}();\n\nGame.prototype.killMote = function () {\n\tvar sum = 0 | 0,\n\t    c = 0 | 0,\n\t    i = 0 | 0,\n\t    pos = vec2(),\n\t    r = 0 | 0,\n\t    g = 0 | 0,\n\t    b = 0 | 0;\n\treturn function killMote(mote) {\n\t\tif (random() < _photonomix3.POSITIVE_ENERGY) {\n\t\t\tthis.entities.push(new _Emitter2.default(mote.pos, mote.vel, ~~(_photonomix3.DEATH_THRESHOLD * 10 * random()), this.photonPool));\n\t\t}\n\t\tif (random() < _photonomix3.NEGATIVE_ENERGY) {\n\t\t\tthis.entities.push(new _Void2.default(mote.pos, mote.vel, ~~(_photonomix3.DEATH_THRESHOLD * 10 * random())));\n\t\t}\n\t\tmut_copy(pos, mote.pos);\n\t\tr = mote.photons[0];\n\t\tg = mote.photons[1];\n\t\tb = mote.photons[2];\n\t\tsum = r + b + g;\n\t\tc = 0;\n\t\tfor (i = 0; i < sum; ++i) {\n\t\t\tif (r === i) c = 1;\n\t\t\tif (r + g === i) c = 2;\n\t\t\tthis.emitPhoton(pos, undefined, c, i, sum);\n\t\t}\n\t};\n}();\n\n/**\n * Actions are callbacks accepting the following parameters:\n * @param {vec2} center center of the click region for the action (i.e. the UI element)\n * @param {float} dist the distance from region center to mouseUp position\n */\nGame.prototype.registerAction = function (name, callback) {\n\tthis.actions[name] = callback.bind(this);\n};\n\nvar delta = vec2();\nGame.prototype.registerActions = function () {\n\tthis.registerAction(\"launchAntiGravitonCluster\", function (center) {\n\t\tminus(this.player.mouseUp, center, delta);\n\t\tthis.entities.push(new _AntiGravitonCluster2.default(center, delta, 148));\n\t});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/game/index.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.ui = exports.sprites = exports.entities = exports.bokeh = undefined;\nexports.updateCompositeOperation = updateCompositeOperation;\nexports.screenSpace = screenSpace;\nexports.screenSpaceVec = screenSpaceVec;\nexports.gameSpaceVec = gameSpaceVec;\nexports.offscreen = offscreen;\nexports.drawCircle = drawCircle;\nexports.tick = tick;\nexports.init = init;\n\nvar _bokeh = require(\"./bokeh\");\n\nvar bokeh = _interopRequireWildcard(_bokeh);\n\nvar _entities = require(\"./entities\");\n\nvar entities = _interopRequireWildcard(_entities);\n\nvar _sprites = require(\"./sprites\");\n\nvar sprites = _interopRequireWildcard(_sprites);\n\nvar _ui = require(\"./ui\");\n\nvar ui = _interopRequireWildcard(_ui);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.bokeh = bokeh;\nexports.entities = entities;\nexports.sprites = sprites;\nexports.ui = ui;\n\n\nvar animating = false; // whether the game is currently running animation loop\nvar game = void 0; // game environment object\nvar controls = void 0; // control state object\nvar props = void 0; // display properties\n\n/**\n * Using this checks and avoids altering the canvas context state machine if unnecessary,\n * which theoretically saves a little time.\n */\nfunction updateCompositeOperation(ctx, op) {\n\tif (ctx.globalCompositeOperation !== op) ctx.globalCompositeOperation = op;\n}\n\n/**\n * Calculates the screenspace pixel offset of a coordinate from the [-1,1] coordinate\n * range used in game position vectors.\n */\nfunction screenSpace(x) {\n\treturn (x + 1) / 2 * props.minDimension;\n}\n\n/**\n * Finds the screen space equivalent of the game space vector v.\n * @param {vec2} v game space vector\n * @param {vec2} out out parameter\n * @return {out}\n */\n\nfunction screenSpaceVec(v, out) {\n\tout[0] = (v[0] + 1) / 2 * props.minDimension;\n\tout[1] = (v[1] + 1) / 2 * props.minDimension;\n\treturn out;\n}\n\n/**\n * Finds the game space equivalent of the sceen space vector v.\n * @param {vec2} v game space vector\n * @param {vec2} out out parameter\n * @return {out}\n */\nfunction gameSpaceVec(v, out) {\n\tout[0] = 2 * (v[0] / props.minDimension) - 1;\n\tout[1] = 2 * (v[1] / props.minDimension) - 1;\n}\n\n/**\n * Checks if entity is out of screen space by more than 50%.\n */\nfunction offscreen(x, y) {\n\treturn x < props.width * -0.5 || x > props.width * 1.5 || y < props.height * -0.5 || y > props.height * 1.5;\n}\n\n/**\n * Draws a colored circle.\n */\nfunction drawCircle(ctx, x, y, size, fillStyle) {\n\tvar lineWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\tvar strokeStyle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n\tctx.globalCompositeOperation = \"source-over\";\n\tctx.beginPath();\n\tctx.arc(x, y, size, 2 * Math.PI, false);\n\tctx.fillStyle = fillStyle;\n\tctx.fill();\n\tif (strokeStyle) {\n\t\tctx.strokeStyle = strokeStyle;\n\t\tctx.lineWidth = lineWidth;\n\t\tctx.stroke();\n\t}\n\tctx.closePath();\n}\n\n/**\n * Main animation loop.\n */\nfunction tick() {\n\tif (!animating) animating = true;\n\tbokeh.draw();\n\tentities.draw(game);\n\tui.draw();\n}\n\n/**\n * Initializes game environment.\n */\nfunction init(state, display) {\n\tgame = state.game;\n\tprops = display.props;\n\tcontrols = state.controls;\n\tbokeh.init(display);\n\tentities.init(display);\n\tui.init(display);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/draw/index.js\n// module id = 4\n// module chunks = 0","\"use strict\";\nimport * as mimeTypes from \"./pxene.assets.mimeTypes\";\n\n/**\n * @Module pxene.assets\n * Handles loading, pre-processing, and caching of remote assets.\n */\n/** @const {Array} list of deferred asset URIs **/\nconst enqueuedURIs = [];\n/** @const {Array} list of currently fetching URIs **/\nconst fetchingURIs = [];\n/** @const {Array} list of completed URIs which should be in the cache **/\nconst completedURIs = [];\n/** @const {Object} a hash of uri->{@link Asset} **/\nconst cache = {};\n/** @const {Object} a hash of handlers by mime type **/\n\nlet globalAssetPrefix = \"\";\nlet fetching = 0;\n\n/**\n * Safely attempt to move an item from one array to another.\n * @return {bool} true if an item was found or moved, otherwise false\n */\nfunction moveItem(item, oldList, newList) {\n\tlet i = oldList.indexOf(item);\n\tif(i !== -1) {\n\t\tnewList.push(oldList.splice(i, 1));\n\t\treturn true;\n\t}\n\telse return false;\n}\n\n/**\n * An object representing a loaded asset.\n * @property uri the uri originally requested for the object (not including global prefixes, domain names, etc)\n * @property {Object} content the processed response, which may be an Image, a string, an SVG, a decoded JSON object, or any other supported value type\n * @property {String} type\n */\nfunction Asset(uri, content, type) {\n\tthis.uri = uri;\n\tthis.content = content;\n\tthis.type = type;\n\treturn this;\n}\n\n/**\n * Fetches an asset from a remote source.\n * @param {String} uri\n */\nfunction fetchAsset(uri) {\n\tif(fetchingURIs.indexOf(uri) === -1 && completedURIs.indexOf(uri) === -1) {\n\t\tfetching++;\n\t\t// add to the fetching list, moving it from enqueuedURIs if needed\n\t\tif(!moveItem(uri, enqueuedURIs, fetchingURIs)) fetchingURIs.push(uri);\n\t\treturn fetch(globalAssetPrefix+uri).then(makeProcessFetchResponse(uri))\t\n\t}\n\telse if(fetchingURIs.indexOf(uri) >= 0) {\n\t\treturn new Promise((resolve) => {\n\t\t\t// @todo event based implementation of this ridiculous shit right here\n\t\t\tlet count = 0;\n\t\t\tlet interval = setInterval(() => {\n\t\t\t\tif(cache[uri] !== undefined) {\n\t\t\t\t\tresolve(cache[uri]);\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t}\n\t\t\t\telse count++;\n\t\t\t\tif(count > 100) {\n\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\tthrow Error(\"stuck in fetching status way too long\");\n\t\t\t\t}\n\t\t\t}, 250);\n\t\t});\n\t}\n\telse if(completedURIs.indexOf(uri) >= 0) {\n\t\treturn Promise.resolve(cache[uri]);\n\t}\n}\n\n\n/**\n * Makes a processFetchResponse binding to ensure the original uri stays in scope.\n */\nfunction makeProcessFetchResponse(uri) {\n\treturn processFetchResponse.bind(null, uri);\n}\n\n/**\n * Processes a response from a fetch request.\n */\nfunction processFetchResponse(uri, response) {\n\treturn new Promise((resolve, reject) => {\n\t\tif(response.ok) {\n\t\t\tlet type = response.headers.get(\"Content-type\");\n\t\t\treturn mimeTypes.getHandler(type)(response)\n\t\t\t\t.then((content) => storeAsset(uri, content, type, resolve));\n\t\t}\n\t\telse reject(\"failed to fetch asset \"+uri);\n\t});\n}\n\n/**\n * Stores an asset in the cache.\n * @param {String} uri the originally requested URI\n * @param {mixed} content the processed response content\n * @param {String} type the mime type of the response\n * @param {function} resolve promise callback for the original fetch request\n */\nfunction storeAsset(uri, content, type, resolve) {\n\tlet item = new Asset(uri, content, type); \n\tcache[uri] = item;\n\tfetching--;\n\tmoveItem(uri, fetchingURIs, completedURIs);\n\tresolve(item);\n}\n\n/**\n * Gets an asset from the cache if available, or else fetches it from a remote source.\n * Returns a promise which resolves with the {@link Asset} requested.\n * @param {String} uri \n * @return Promise\n */\nexport function requestAsset(uri) {\n\tlet item = cache[uri];\n\tif(item === undefined) return fetchAsset(uri);\n\telse return Promise.resolve(item);\n}\n\nexport function requestAssetList(list) {\n\treturn Promise.all(list.map((item) => requestAsset(item)));\n}\n\n/**\n * Enqueues an asset to be fetched. Enqueued assets are fetched later when processQueue is called.\n */\nexport function enqueueAsset(uri) {\n\tif(enqueuedURIs.indexOf(uri) === -1 && fetchingURIs.indexOf(uri) === -1 && cache[uri] === undefined) enqueuedURIs.push(uri);\n}\n\n/**\n * Enqueues a list of assets to be fetched layer during a processQueue() call.\n * @param {Array} list array of URIs to load\n * @returns {Promise|undefined}\n */\nexport function enqueueAssetList(list) {\n\tlist.forEach(item => enqueueAsset(item)); \n}\n\n/**\n * Process any deferred items in the queue.\n * @return {Promise} a promise that resolves when all the items are fetched with an array of all the fetched items\n */\nexport function processQueue() {\n\treturn Promise.all(enqueuedURIs.map((uri) => fetchAsset(uri)));\n}\n\n/**\n * Sets the globalAssetPrefix, which is prepended to all fetch URIs.\n * @param {string} prefix a string representing a path or filename prefix\n */\nexport function setGlobalAssetPrefix(prefix) {\n\tglobalAssetPrefix = prefix;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.assets.js\n// module id = 5\n// module chunks = 0","export const TARGET_FPS = 30;\nexport const GRAVITY = 6.67408e-8;\nexport const GLOBAL_DRAG = 0.1;\n\n// general debug switch\nexport const DEBUG = true;\n// toggles vector validation in various functions that tend to produce\n// infinite or NaN results; when enabled, vectors are checked and if invalid\n// the function is rerun step by step and logged to identify trouble spots\nexport const VALIDATE_VECTORS = DEBUG || true;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.constants.js\n// module id = 6\n// module chunks = 0","\"use strict\";\nimport {VALIDATE_VECTORS, GRAVITY} from \"./pxene.constants\";\nimport {vectors} from \"@nphyx/vectrix\";\nconst {minus,mut_clamp,mut_copy,mut_times,normalize,mut_normalize,magnitude,vec2} = vectors;\nconst {sqrt, abs, floor, ceil, round} = Math;\nconst MIN_F = 1e-11;\nconst MAX_F = 1e+11;\n\n/**\n * Round to nearest even number.\n */\nexport function evenNumber(n) {\nreturn n >> 1 << 1;\n}\n\nexport function tan_vec(v, out) {\n\tlet tmpx = 0;\n\tnormalize(v, out);\n\ttmpx = out[0];\n\tout[0] = -out[1];\n\tout[1] = tmpx;\n\treturn out;\n}\n\nexport function perpdot(a, b) {\n\treturn a[0]*b[1] - b[0]*a[1];\n}\n\nexport function floor_vec(v, out) {\n\tlet len = v.length;\n\tout = out || vectors.create(len);\n\tfor(let i = 0; i < len; ++i) {\n\t\tout[i] = floor(v[i]);\n\t}\n\treturn out;\n}\n\nexport function mut_floor_vec(v) {\n\treturn floor_vec(v, v);\n}\n\nexport function ceil_vec(v, out) {\n\tlet len = v.length;\n\tout = out || vectors.create(len);\n\tfor(let i = 0; i < len; ++i) {\n\t\tout[i] = ceil(v[i]);\n\t}\n\treturn out;\n}\n\nexport function mut_ceil_vec(v) {\n\treturn ceil_vec(v, v);\n}\n\nexport function round_vec(v, out) {\n\tlet len = v.length;\n\tout = out || vectors.create(len);\n\tfor(let i = 0; i < len; ++i) {\n\t\tout[i] = round(v[i]);\n\t}\n\treturn out;\n}\n\nexport function mut_round_vec(v) {\n\treturn round_vec(v, v);\n}\n\n/**\n * Clamp the absolute value of a number, keeping its sign.\n */\nfunction limit(v, min_v = 0, max_v = Infinity) {\n\tif(abs(v) < abs(min_v)) {\n\t\tif(v < 0) v = -min_v;\n\t\telse v = min_v;\n\t}\n\telse if(abs(v) > abs(max_v)) {\n\t\tif(v < 0) v = -max_v;\n\t\telse v = max_v;\n\t}\n\treturn v;\n}\n\n/**\n * Limits absolute values of vectors within a range.\n */\nexport const limitVecMut = (function() {\n\tlet i = 0|0, l = 0|0;\n\treturn function limitVecMut(v, min_v = 0, max_v = Infinity) {\t\n\t\tfor(i = 0, l = v.length; i < l; ++i) {\n\t\t\tv[i] = limit(v[i], min_v, max_v);\n\t\t}\n\t}\n})();\n\n/**\n * Validates a vector. For debugging purposes.\n */\nexport const validate = (function() {\n\tlet i, l;\n\treturn function validate(v) {\n\t\tfor(i = 0, l = v.length; i < l; i++) {\n\t\t\tif(isNaN(v[i])) throw new Error(\"NaN vector\");\n\t\t\tif(v[i] === Infinity) throw new Error(\"Infinite vector\");\n\t\t\tif(v[i] === -Infinity) throw new Error(\"-Infinite vector\");\n\t\t}\n\t}\n})();\n\n/**\n * Gravitate toward target.\n */\nexport const gravitate = (function() {\n\tlet g_v = vec2();\n\tlet mag = 0.0, x = 0.0, y = 0.0, scale = 0.0;\n\treturn function gravitate(p1, p2, strength, out) {\n\t\tout = out||g_v;\n\t\tminus(p1, p2, out);\n\t\tmag = magnitude(out);\n\t\t// inline normalize for speed, since this happens a lot\n\t\tx = out[0];\n\t\ty = out[1];\n\t\tif((x === 0 && y === 0) || mag === 0) return out;\n\t\tscale = mut_clamp(1/sqrt((x*x)+(y*y)), MIN_F, MAX_F);\n\t\tstrength = mut_clamp(strength, -MAX_F, MAX_F);\n\t\tout[0] = x*scale;\n\t\tout[1] = y*scale;\n\t\t//mut_normalize(out);\n\t\tmut_times(out, -strength*GRAVITY/(mag*mag));\n\t\tif(VALIDATE_VECTORS) {\n\t\t\ttry {\n\t\t\t\tvalidate(out);\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\tconsole.log(\"gravitation error\", e);\n\t\t\t\tconsole.log(strength);\n\t\t\t\tminus(p1, p2, out);\n\t\t\t\tconsole.log(\"minus\", out);\n\t\t\t\tlimitVecMut(out, 0.00001, 10); // put a cap on it to avoid infinite acceleration\n\t\t\t\tconsole.log(\"limit\", out);\n\t\t\t\tmag = magnitude(out);\n\t\t\t\tconsole.log(\"magnitude\", mag);\n\t\t\t\tmut_normalize(out);\n\t\t\t\tconsole.log(\"normalize\", out);\n\t\t\t\tmut_times(out, -strength/(mag*mag));\n\t\t\t\tconsole.log(\"scale\", out);\n\t\t\t\tout.fill(0.0);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Accelerate toward a target.\n */\nexport const accelerate = (function() {\n\tlet v = vec2();\n\tlet scale = 0.0, x = 0.0, y = 0.0;\n\treturn function accelerate(p1, p2, strength, out) {\n\t\tout = out||v;\t\n\t\tminus(p1, p2, out);\n\t\tx = out[0];\n\t\ty = out[1];\n\t\tif(x === 0 && y === 0) return out;\n\t\tscale = mut_clamp(1/sqrt((x*x)+(y*y)), MIN_F, MAX_F);\n\t\tstrength = mut_clamp(strength, -MAX_F, MAX_F);\n\t\t// inline normalize for speed, since this happens a lot\n\t\tout[0] = x*scale;\n\t\tout[1] = y*scale;\n\t\t//mut_normalize(out);\n\t\tmut_times(out, -strength);\n\t\tif(VALIDATE_VECTORS) {\n\t\t\ttry {\n\t\t\t\tvalidate(out);\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\tconsole.log(\"acceleration error\", e);\n\t\t\t\tconsole.log(\"strength\", strength);\n\t\t\t\tminus(p1, p2, out);\n\t\t\t\tconsole.log(\"minus\", out);\n\t\t\t\tmut_normalize(out);\n\t\t\t\tconsole.log(\"normalize\", out);\n\t\t\t\tmut_times(out, -strength);\n\t\t\t\tconsole.log(\"scale\", out);\n\t\t\t\tout.fill(0.0);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n})();\n\nexport const drag = (function() {\n\tlet delta = vec2(), dragStrength = 0.0, dragSpeed = 0.0;\n\tlet scale = 0.0, x = 0.0, y = 0.0;\n\t/**\n\t * Apply drag.\n\t */\n\treturn function drag(vel, c, out) {\n\t\tout = out||delta;\n\t\tdragSpeed = magnitude(vel);\n\t\t// null small values\n\t\tdragSpeed = limit(dragSpeed, 0, 1e+11); // avoid infinite dragSpeeds\n\t\tdragStrength = mut_clamp(c * dragSpeed * dragSpeed, 1e-11, 1e+11);\n\t\tmut_copy(out, vel);\n\t\tx = out[0];\n\t\ty = out[1];\n\t\tif((x === 0 && y === 0) || dragStrength === 0) return out;\n\t\t// inline normalize for speed, since this happens a lot\n\t\tscale = mut_clamp(1/sqrt((x*x)+(y*y)), MIN_F, MAX_F);\n\t\tdragStrength = mut_clamp(dragStrength, MIN_F, MAX_F);\n\t\tout[0] = x*scale;\n\t\tout[1] = y*scale;\n\t\t// mut_normalize(out)\n\t\tmut_times(out, -1);\n\t\tmut_times(out, dragStrength);\n\t\tif(VALIDATE_VECTORS) {\n\t\t\ttry {\n\t\t\t\tvalidate(out);\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\tconsole.log(\"drag error\", e);\n\t\t\t\tconsole.log(c, dragSpeed, dragStrength);\n\t\t\t\tconsole.log(\"magnitude\", magnitude(vel));\n\t\t\t\tmut_copy(out, vel);\n\t\t\t\tconsole.log(\"copied\", out);\n\t\t\t\tmut_normalize(out);\n\t\t\t\tconsole.log(\"normalized\", out);\n\t\t\t\tmut_times(out, -1);\n\t\t\t\tconsole.log(\"inverted\", out);\n\t\t\t\tmut_times(out, dragStrength);\n\t\t\t\tconsole.log(\"scaled\", out);\n\t\t\t\tout.fill(0.0);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n\n/**\n * Checks if entity is out of screen space by more than 50%.\n */\nexport function offscreen(x, y, displayProps) {\n\treturn (\n\t\tx < (displayProps.width  * -0.5) || x >displayProps.width   * 1.5 ||\n\t\ty < (displayProps.height * -0.5) || y > displayProps.height * 1.5\n\t)\n}\n\n/**\n * Calculates the screenspace pixel offset of a coordinate from the [-1,1] coordinate\n * range used in game position vectors.\n */\nexport function screenSpace(x, displayProps) {\n\treturn ((x+1)/2) * displayProps.minDimension;\n}\n\n/**\n * Finds the screen space equivalent of the game space vector v.\n * @param {vec2} v game space vector\n * @param {vec2} out out parameter\n * @return {out}\n */\n\nexport function screenSpaceVec(v, displayProps, out) {\n\tout[0] = (((v[0]+1)/2)*displayProps.minDimension);\n\tout[1] = (((v[1]+1)/2)*displayProps.minDimension);\n\treturn out;\n}\n\n/**\n * Finds the game space equivalent of the sceen space vector v.\n * @param {vec2} v game space vector\n * @param {vec2} out out parameter\n * @return {out}\n */\nexport function gameSpaceVec(v, displayProps, out) {\n\tout[0] = 2*((v[0])/displayProps.minDimension)-1;\n\tout[1] = 2*((v[1])/displayProps.minDimension)-1;\n}\n\n/**\n * Flattens an array. \n * @function flatten\n * @param {mixed} a an array, array-like, or object that can be flattened\n * @return {mixed} flat version of input\n */\nexport function flatten(a) {\n\t// cheap array-like check, may not always be reliable\n\tif(a instanceof Object && typeof a.length == \"number\") {\n\t\tlet i = 0, len = a.length, out = [];\n\t\tfor(;i < len; ++i) {\n\t\t\tout = out.concat(flatten(a[i]));\n\t\t}\n\t\treturn out;\n\t}\n\telse return a;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.util.js\n// module id = 7\n// module chunks = 0","/**\nRequire the module:\n```javascript\nconst matrices = require(\"vectrix.matrices.js\");\n```\n\nCreate a 2x2 matrix using `create(rows, columns, values)`:\n```javascript\nlet mat = matrices.create(2,2,[0,1, 2,3]);\n```\n\nAdd two matrices using `a.plus(b)`:\n```javascript\nlet first =  matrices.create(2,2,[1,2, 3,4]);\nlet second = matrices.create(2,2,[3,4, 5,6]);\nlet sum = first.plus(second);\n```\n\nSubtract two matrices with `a.minus(b)`:\n```javascript\nlet diff = second.minus(first);\n```\n\nGet the dot product of two matrices via `a.dot(b)`:\n```javascript\nlet prod = first.dot(second);\n```\n\nDot can also multiply a matrix by a scalar:\n```javascript\nlet scalarProd = first.dot(3);\n```\n\nAll matrix and vector methods produce a new object from their operands, creating and\nreturning a new object as a result.\n```javascript\nsum.toArray(); // [4,6,8,10]\ndiff.toArray(); // [2,2,2,2]\nproduct.toArray(); // [13,16,29,26]\nfirst.toArray(); // [1,2,3,4]\nsecond.toArray(); // [3,4,5,6]\nscalarProd; // [3,6,9,12]\n```\n\nThis means matrix operations are composable in an intuitive left-to-right fashion:\n```javascript\nfirst.sub(second).dot(diff).toArray(); // [8,8,8,8]\n```\n\nBut keep in mind that you must follow matrix operation rules! Operating on two\nincompatible matrices returns undefined:\n```javascript\nlet third = matrices.create(1,2,[0,1]);\nfirst.add(third); // undefined\n```\n\nIt turned out to be useful to get a single row or column from a matrix, so you can\ndo that too using `mat.row(N)` and `mat.col(N)`:\n```javascript\nfirst.row(0); // matrix(2,1,[1,2])\nfirst.col(1); // matrix(1,2,[2,4])\n```\n@module vectrix/matrices\n*/\n\n\"use strict\";\n// set the max size for certain matrix operations, used in creating scratch memory\n//const MBF = 20;\nconst {cos, sin} = Math;\nimport * as vectors from \"./vectrix.vectors\";\nconst vec = vectors.create;\n\n/**\n * Flattens an array. Used for flattening arguments passed to factories. \n * @function flatten\n * @param {mixed} a an array, array-like, or object that can be flattened\n * @return {mixed} flat version of input\n */\nexport function flatten(a) {\n\t// cheap array-like check, may not always be reliable\n\tif(a instanceof Object && typeof a.length == \"number\") {\n\t\tlet i = 0, len = a.length, out = [];\n\t\tfor(;i < len; ++i) {\n\t\t\tout = out.concat(flatten(a[i]));\n\t\t}\n\t\treturn out;\n\t}\n\telse return a;\n}\n\n/**\n * Tests whether two unknown objects are like matrices (same rows and columns) or\n * a compatible set of matrix and vector.\n * @param {Matrix|Vector} a \n * @param {Matrix|Vector} b \n * @return {bool}\n */\nexport function likeMatrices(a, b) {\n\treturn (\n\t\t// matrices\n\t\t(a.rows ===  b.rows) && (a.cols === b.cols) ||\n\t\t// vectors\n\t\t((a.rows === undefined && b.rows === undefined) &&\n\t\t\ta.length === b.length) ||\n\t\t// matrix / vector\n\t\t(b.cols === 1 && b.cols === undefined && a.rows === b.length) ||\n\t\t// vector / matrix\n\t\t(a.rows === 1 && b.rows === undefined && a.cols === b.length)\n\t);\n}\n\n/**\n * Add two matrices together.\n * @example\n * plus(matrix, anotherMatrix); // function\n * matrix.plus(anotherMatrix); // method\n * @function plus\n * @param {matrix} a first matrix\n * @param {matrix} b second matrix\n * @param {matrix} out out value (optional)\n * @return {matrix}\n */\nexport const plus = (function() {\n\tlet i = 0|0, l = 0|0, ar = 0|0, ac = 0|0;\n\treturn function plus(a, b, out) {\n\t\tif(!likeMatrices(a, b)) return undefined;\n\t\tl = a.length;//-1;\n\t\tar = a.rows;\n\t\tac = a.cols;\n\t\tout = out||create.similar(a);\n\t\tfor(i = 0|0; i < l; ++i) {\n\t\t\tout[i] = a[i] + b[i]\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [plus](#plus).\n *\n * @function mut_plus\n * @param {matrix} a first matrix\n * @param {matrix} b second matrix\n * @param {matrix} out out value (optional)\n * @return {matrix}\n */\nexport function mut_plus(a, b) {\n\treturn plus(a, b, a);\n}\n\n/**\n * Add a scalar to a matrix.\n * plus_scalar(matrix, anotherMatrix); // function\n * matrix.plus_scalar(anotherMatrix); // method\n * @function plus\n * @param {matrix} a first matrix\n * @param {matrix} s scalar\n * @param {matrix} out (optional) out value\n * @return {matrix}\n */\nexport const plus_scalar = (function() {\n\tlet i = 0|0;\n\treturn function plus_scalar(a, s, out) {\n\t\tout = out||create(a.rows, a.cols);\n\t\ts = +s;\n\t\ti = a.length;//-1;\n\t\twhile(i--) {\n\t\t\tout[i] = a[i] + s;\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [plus](#plus).\n * @function mut_plus\n * @param {matrix} a first matrix\n * @param {matrix} s second matrix\n * @return {matrix}\n */\nexport function mut_plus_scalar(a, s) {\n\treturn plus_scalar(a, s, a);\n}\n\n/**\n * Subtract matrices.\n * @example\n * minus(matrix, anotherMatrix); // function\n * matrix.minus(anotherMatrix); // method\n * @param {matrix} a first matrix\n * @param {matrix} b second matrix\n * @return {matrix}\n */\nexport const minus = (function() {\n\tlet i = 0|0, ac = 0|0, ar = 0|0;\n\treturn function minus(a, b, out) {\n\t\tif(!likeMatrices(a, b)) return undefined;\n\t\ti = a.length;//-1;\n\t\tar = a.rows || 0;\n\t\tac = a.cols || i;\n\t\tout = out||create.similar(a);\n\t\twhile(i--) {\n\t\t\tout[i] = a[i] - b[i]\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [minus](#minus).\n *\n * @function mut_minus\n * @param {matrix} a first matrix\n * @param {matrix} b second matrix\n * @param {matrix} out out value (optional)\n * @return {matrix}\n */\nexport function mut_minus(a, b) {\n\treturn minus(a, b, a);\n}\n\n/**\n * subtract a scalar to a matrix.\n * minus_scalar(matrix, anotherMatrix); // function\n * matrix.minus_scalar(anotherMatrix); // method\n * @function minus\n * @param {matrix} a first matrix\n * @param {matrix} s scalar\n * @param {matrix} out (optional) out value\n * @return {matrix}\n */\nexport const minus_scalar = (function() {\n\tlet i = 0|0;\n\treturn function minus_scalar(a, s, out) {\n\t\tout = out||create(a.rows, a.cols);\n\t\ts = +s;\n\t\ti = a.length;//-1;\n\t\twhile(i--) {\n\t\t\tout[i] = a[i] - s;\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [minus](#minus).\n * @function mut_minus\n * @param {matrix} a first matrix\n * @param {matrix} s second matrix\n * @return {matrix}\n */\nexport function mut_minus_scalar(a, s) {\n\treturn minus_scalar(a, s, a);\n}\n\n/**\n * Get a single column from a matrix.\n * @example\n * col(matrix, 2); // function\n * matrix.col(2); // method\n * @param {matrix} a source matrix\n * @param {n} column number (zero indexed)\n * @param {matrix} out (optional) out parameter, same rows, 1 column\n * @return {matrix} a single column from the source matrix\n */\nexport const col = (function() {\n\tlet i = 0|0, len = 0|0;\n\treturn function col(a, n, out) {\n\t\tout = out||create(a.rows, 1);\n\t\tlet cols = a.cols;\n\t\tfor(i = 0, len = a.rows; i < len; ++i) {\n\t\t\tout[i] = a[i*cols+n]\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Get a single row from a matrix.\n * @example\n * row(matrix, 2); // function\n * matrix.row(2); // method\n * @param {matrix} a source matrix\n * @param {n} row number (zero indexed)\n * @param {matrix} out (optional) out parameter with rows = a.cols, cols = 1 \n * @return {matrix} a single row from the source matrix\n */\nexport const row = (function() {\n\tlet i = 0|0, len = 0|0;\n\treturn function row(a, n, out) {\n\t\tout = out||create(1, a.cols);\n\t\tlet cols = a.cols;\n\t\tfor(i = 0, len = a.cols; i < len; ++i) {\n\t\t\tout[i] = a[cols*n+i]\n\t\t}\n\t\treturn out;\n\t}\n})();\n\nexport const multiply_scalar = (function() {\n\tlet i = 0|0, len = 0|0;\n\treturn function multiply_scalar(a, s, out) {\n\t\tout = out||create(a.rows, a.cols);\n\t\tfor(i = 0, len = a.length; i < len; ++i) {\n\t\t\tout[i] = a[i] * s;\n\t\t}\n\t\treturn out;\n\t}\n})();\n\nexport function mut_multiply_scalar(a, s) {\n\treturn multiply_scalar(a, s, a);\n}\n\n/**\n * Multiply matrices or vectors.\n * @example\n * dot(matrix, anotherMatrix); // function \n * matrix.dot(anotherMatrix); // method\n * @param {matrix} a first matrix\n * @param {matrix} b second matrix\n * @param {matrix} out (optional) out parameter \n * @return {matrix}\n */\nexport const dot = (function() {\n\tlet blen = 0|0, brow = 0|0, bcol = 0|0, bcols = 0|0, brows = 0|0, bpos = 0|0;\n\tlet acols = 0|0, arows = 0|0, arow = 0|0, aroff = 0|0, apos = 0|0;\n\tlet opos = 0|0;\n\treturn function dot(a, b, out) {\n\t\tacols = (a.cols !== undefined)?a.cols:a.length;\n\t\tbrows = (b.rows !== undefined)?b.rows:b.length;\n\t\tif(acols === brows) {\n\t\t\tarows = (a.rows !== undefined)?a.rows:1;\n\t\t\tbcols = (b.cols !== undefined)?b.cols:1;\n\t\t\tblen = b.length;\n\t\t\tout = out||create(arows, bcols);\n\t\t\t//out.fill(0.0);\n\t\t\topos = 0;\n\t\t\tfor(arow = 0; arow < arows; ++arow) { \n\t\t\t\taroff = arow * acols;\n\t\t\t\tfor(bpos = 0|0; bpos < blen; ++bpos) {\n\t\t\t\t\tbcol = bpos % bcols;\n\t\t\t\t\tbrow = (bpos / bcols)|0; // bitwise floor is safe here and faster\n\t\t\t\t\topos = (bcols * arow) + bcol;\n\t\t\t\t\tapos = (aroff + brow);\n\t\t\t\t\tout[opos] = out[opos] + b[bpos] * a[apos];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\telse return undefined;\n\t}\n})();\n\n\n/**\n * Get the basic array representation of a matrix.\n * @example\n * toArray(matrix); // function\n * matrix.toArray(); // method\n * @param {matrix} a\n * @return {array} values as flat array\n */\nexport function toArray(a) {\n\treturn Array.prototype.slice.apply(a);\n}\n\n/**\n * Get a nicely formatted string representation of a matrix.\n * @example\n * matToString(matrix); // function\n * matrix.toString(); // method\n * @param {matrix} a\n * @return {string}\n */\nexport const toString = (function() {\n\tlet label = \"matrix(\", string = \"\", c = 0|0, r = 0|0, i = 0|0, len = 0|0,\n\t\tstrings, colWidth, row;\n\tfunction padLeft(l,s) {\n\t\treturn ((\" \").repeat(l)+s).slice(-l);\n\t}\n\tfunction makeStrings(a) {\n\t\treturn toArray(a).map((cur) => cur.toFixed(2));\n\t}\n\treturn function toString(a) {\n\t\tc = a.cols|0;\n\t\tr = a.rows|0;\n\t\tstring = label;\n\t\tstrings = makeStrings(a);\n\t\tcolWidth = strings.reduce((a, b) => Math.max(a, b.length), 0);\n\t\tfor(i = 0; i < r; ++i) {\n\t\t\trow = strings.slice(i*c, 2*(i+1)*c);\n\t\t}\n\t\tfor(i = 0, len = strings.length; i < len; ++i) {\n\t\t\tstrings[i] = padLeft(colWidth, strings[i]);\n\t\t\tif(i > 0) {\n\t\t\t\tif(i % c === 0) string += \"\\n       \";\n\t\t\t\telse string += \", \";\n\t\t\t}\n\t\t\tstring += strings[i];\n\t\t}\n\t\treturn string + \")\";\n\t}\n})();\n\n/*\n * Matrix factories\n */\n\n/**\n * Factory for creating generic matrices.\n * @function create\n * @param {int} rows matrix rows\n * @param {int} cols matrix columns\n * @param {mixed} values (optional) matrix values as an array-like object\n * @param {ArrayBuffer} buffer (optional) pre-supplied ArrayBuffer\n * @param {int} offset (optional) offset for buffer\n * @return {matrix}\n */\nexport function create(rows, cols, values = [], buffer = undefined, offset = 0) {\n\tvar matrix;\n\tif(buffer) {\n\t\tmatrix = new Float32Array(buffer, offset, cols * rows);\n\t}\n\telse {\n\t\tmatrix = new Float32Array(cols * rows);\n\t}\n\tvar vals = flatten(values);\n\tmatrix.rows = rows;\n\tmatrix.cols = cols;\n\tif(vals.length) matrix.set(vals);\n\telse matrix.fill(0.0); // just in case it was a previously used buffer\n\treturn matrix;\n}\n\n/**\n * Creates a matrix or vector similar to the one given.\n */\ncreate.similar = function(a, ...args) {\n\tif(a.rows && a.cols) return create.apply(null, [a.rows, a.cols].concat(args));\n\telse return vec.apply(null, [a.length].concat(args));\n}\n\n/**\n * Wraps an matrix (created by [create](#create)) with matrix methods.\n * @param {array-like} matrix a matrix, Array, or Float32Array to wrap as a matrix\n * @param {int} rows (required for non-matrices) number of rows the matrix should have\n * @param {int} cols (required for non-matrices) number of columns the matrix should have\n * @return {matrix} a wrapped matrix\n */\nexport function wrap(matrix, rows, cols) {\n\tmatrix.rows = rows||matrix.rows;\n\tmatrix.cols = cols||matrix.cols;\n\tmatrix.toArray = toArray.bind(null, matrix);\n\tmatrix.toString = toString.bind(null, matrix);\n\tmatrix.col = col.bind(null, matrix);\n\tmatrix.row = row.bind(null, matrix);\n\tmatrix.plus = plus.bind(null, matrix);\n\tmatrix.plus_scalar = plus_scalar.bind(null, matrix);\n\tmatrix.minus = minus.bind(null, matrix);\n\tmatrix.minus_scalar = minus_scalar.bind(null, matrix);\n\tmatrix.dot = dot.bind(null, matrix);\n\tmatrix.multiply_scalar = multiply_scalar.bind(null, matrix);\n\tmatrix.mut_plus = mut_plus.bind(null, matrix);\n\tmatrix.mut_plus_scalar = mut_plus_scalar.bind(null, matrix);\n\tmatrix.mut_minus = mut_minus.bind(null, matrix);\n\tmatrix.mut_minus_scalar = mut_minus_scalar.bind(null, matrix);\n\treturn matrix;\n}\n\n/**\n * Creates an identity matrix of arbitrary dimensions.\n * @example\n * matrices.create.identity(4); // a 4x4 identity matrix\n * @param {int} n dimensions of the matrix\n * @param {ArrayBuffer} buffer (optional) pre-supplied ArrayBuffer\n * @param {int} offset (optional) offset for buffer\n * @return {matrix} identity matrix \n */\ncreate.identity = (function() {\n\tlet i = 0|0, len = 0|0, j = 0|0;\n\treturn function identity(n, buffer = undefined, offset = 0) {\n\t\tn = n|0;\n\t\tlet m = create(n, n, undefined, buffer, offset);\n\t\tfor(i = 0|0, len = n*n, j = n+1|0; i < len; i+=j) m[i] = 1.0;\n\t\treturn m;\n\t}\n})();\n\n/**\n * Creates a translation matrix for a homogenous coordinate in 2D or 3D space. \n * @example\n * let vec = vectors.create.vec3(3,4,5).toHomogenous();\n * matrices.create.identity(vec); // translates by 3x, 4y, 5z\n * @param {vector} v vector representing the distance to translate \n * @return {matrix} 3x3 or 4x4 matrix\n */\ncreate.translation = (function() {\n\tlet v2 = Float32Array.from([1.0,0.0,0.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,1.0,0.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,0.0,1.0]); \n\tlet v3 = Float32Array.from([1.0,0.0,0.0,0.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  0.0,1.0,0.0,0.0, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,0.0,1.0,0.0, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,0.0,0.0,1.0]);\n\treturn function translation(v, buffer = undefined, offset = 0) {\n\t\tswitch(v.length) {\n\t\t\tcase 2: \n\t\t\t\tv2[2] = v[0];\n\t\t\t\tv2[5] = v[1];\n\t\t\t\treturn create(3, 3, v2, buffer, offset);\n\t\t\tcase 3: \n\t\t\t\tv3[3]  = v[0];\n\t\t\t\tv3[7]  = v[1];\n\t\t\t\tv3[11] = v[2];\n\t\t\t\treturn create(4, 4, v3, buffer, offset);\n\t\t\tdefault: return undefined;\n\t\t}\n\t}\n})();\n\n/**\n * Creates a rotation matrix around absolute X axis of angle r.\n * @example\n * matrices.create.rotateX(1.5708); // 90 degree rotation around X axis\n * @param {radian} r angle as a radian\n * @return {matrix} 3x3 matrix\n */\ncreate.rotateX = (function() {\n\tlet cosr = 0.0, sinr = 0.0, scratch = Float32Array.from([\n\t\t1.0,0.0,0.0,\n\t\t0.0,1.0,0.0,\n\t\t0.0,0.0,1.0\n\t]);\n\treturn function rotateX(r, buffer = undefined, offset = 0) {\n\t\tcosr = cos(r);\n\t\tsinr = sin(r);\n\t\tscratch[4] = cosr;\n\t\tscratch[5] = -sinr;\n\t\tscratch[7] = sinr;\n\t\tscratch[8] = cosr;\n\t\treturn create(3, 3, scratch, buffer, offset);\n\t}\n})();\n\n/**\n * Creates a rotation matrix around absolute Y axis of angle r.\n * @example\n * matrices.create.rotateY(1.5708); // 90 degree rotation around Y axis\n * @param {radian} r angle as a radian\n * @return {matrix} 3x3 matrix\n */\ncreate.rotateY = (function() {\n\tlet cosr = 0.0, sinr = 0.0, scratch = Float32Array.from([\n\t\t1.0,0.0,0.0,\n\t\t0.0,1.0,0.0,\n\t\t0.0,0.0,1.0\n\t]);\n\treturn function rotateY(r, buffer = undefined, offset = 0) {\n\t\tcosr = cos(r);\n\t\tsinr = sin(r);\n\t\tscratch[0] = cosr;\n\t\tscratch[2] = sinr;\n\t\tscratch[6] = -sinr;\n\t\tscratch[8] = cosr;\n\t\treturn create(3, 3, scratch, buffer, offset);\n\t}\n})();\n\n/**\n * Creates a rotation matrix around absolute Z axis of angle r.\n * @example\n * matrices.create.rotateZ(1.5708); // 90 degree rotation around Z axis\n * @param {radian} r angle as a radian\n * @return {matrix} 3x3 matrix\n */\ncreate.rotateZ = (function() {\n\tlet cosr = 0.0, sinr = 0.0, scratch = Float32Array.from([\n\t\t1.0,0.0,0.0,\n\t\t0.0,1.0,0.0,\n\t\t0.0,0.0,1.0\n\t]);\n\treturn function rotateZ(r, buffer = undefined, offset = 0) {\n\t\tcosr = cos(r);\n\t\tsinr = sin(r);\n\t\tscratch[0] = cosr;\n\t\tscratch[1] = -sinr;\n\t\tscratch[3] = sinr;\n\t\tscratch[4] = cosr;\n\t\treturn create(3, 3, scratch, buffer, offset);\n\t}\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-vectrix/src/vectrix.matrices.js\n// module id = 8\n// module chunks = 0","/**\nThe vectors module contains functions and objects related to 2d, 3d, and 4d vectors.\n\nVectors are composed from columnar matrices, so they support all the methods that\n[[vectrix.matrices|matrices]] do.\n\nRequire the vector module:\n```javascript\nconst vectors = require(\"vectrix.vectors.js\");\nconst vec2 = vectors.create.vec2;\nconst vec3 = vectors.create.vec3;\nconst vec4 = vectors.create.vec4;\n```\n\n\nYou can construct them with vec2, vec3, and vec4, passing zero, one or N arguments\nwhere N is the vector size. Do whatever is convenient.\n```javascript\nlet first = vec2(); // passing no arguments will give you a vector filled with zeroes\nfirst.toArray(); // [0,0]\nlet second = vec2([3,7]); // you can pass an array-like object\nsecond.toArray(); // [3,7] \nlet third = vec2(17,4); // or just pass the components as arguments\nthird.toArray(); // [14,4] \nlet fourth = vec3(1,2,3); // and so on with 3d and 4d vectors\nfourth.toArray(); // [1,2,3]\n```\n\nVector functions will operate on any array-like object, returning a plain Float32Array when the result is another vector. Creating vector objects is somewhat expensive, so when you're doing a lot of operations and performance really counts, use the functions for calculations and then use the vector factories on your final result.\n```javascript\nconst lerp = vectors.lerp;\nlet res = lerp([0.1, 0.3], [0.3, 0.7], .5); // Float32Array(0.2, 0.5)\ncreate.vec2(res); // vec2(0.2,0.5);\n```\n\nVectors are composed from columnar matrices, so they can do the things that matrices\ndo. \n```javascript\nsecond.add(second).toArray(); // [6,14]\nthird.sub(second).toArray(); // [11,-3]\n\nconst matrices = require(\"vectrix.matrices.js\");\nlet identity = matrices.create(2,2,[1,0, 0,1]);\nidentity.dot(second).toArray(); // [3,7]\nlet scale2x = matrixes.create(2,2,[2,0, 0,2]);\nscale2x.dot(third).toArray(); // [34,8]\n```\n\nVector dot products are a special case. As in vector math, multplying two vectors\nproduces a scalar:\n```javascript\nlet first = vec2(2,2);\nlet second = vec2([2,2]);\nfirst.dot(second); // 8\nlet third = vec2(1,0);\nlet fourth = vec2(0,1);\nthird.dot(fourth); // 0\n```\n\nThey also have some of their own useful properties.\n\nYou can find the cross product of two 3d vectors using `vec.cross()`:\n```javascript\nlet first = vec3(1,2,1);\nlet second = vec3(2,-2,2);\nfirst.cross(second).toArray(); // [6,0,-6]\n```\nCross can be called on 2d vectors, with z implicitly being zero:\n```javascript\nlet first = vec2(2,4);\nlet second = vec2(1,3);\nfirst.cross(second).toArray(); // [0,0,2]\n```\n\nIf you cross a vec2 with a vec3 for whatever reason, vec2.z is implicitly zero:\n```javascript\nlet first = vec3(1,2,1);\nlet second = vec2(1,3);\nfirst.cross(second).toArray(); // [-3,1,1]\n```\n\nMost vector operations are duck typed and make few assumptions internally, so you \ncan just pass in anything array-like of the correct length if you want:\n```javascript\nlet first = vec3(1,2,1);\nfirst.cross([2,-2,2]).toArray(); // [6,0,-6]\n```\nJust beware weird behavior might result if it looks like a duck and quacks like a duck\nbut it's actually a trick-or-treating platypus.\n\nYou can produce a homogenous coordinate for matrix multiplication using `vec.homogenous()`:\n```javascript\nfirst.homogenous().toArray(); // [0,0,1]\n```\n\nWhich lets you do a few useful matrix-vector ops more easily:\n```javascript\nconst matrices = require(\"vectrix.matrices.js\");\nconst vectors = require(\"vectrix.vectors.js\");\nlet myVec = vectors.vec2([22,9]); \nlet translate = matrices.create(3,3,[1,0,5, 0,1,6, 0,0,1]);\ntranslate.dot(myVec.homogenous()).toArray(); // [27,15,1]\n```\nMaking this more intuitive is on the roadmap.\n\nLast but not least, they have a whole bunch of virtual properties that you might\nbe used to in GLSL. Once I used them I couldn't live without.\n```javascript\nlet position = vectors.vec3([0,-0.5,0.5]);\nposition.x; // 0\nposition.y; // -0.5\nposition.z; // 0.5\nposition.xy; // vec2(0,-0.5)\nposition.zx; // vec2(0.5,0)\nposition.yzx; // vec3(-0.5,0.5,0)\nlet color = vectors.vec4(255,128,64,0.1)\ncolor.rgb; // vec3(255,128,64)\ncolor.bgr; // vec3(64,128,255)\n```\n...and so on - all aliases and combinations thereof for the xyzw and rgba sets\nare available. vec2s only support x/y because r/g is not useful.\n@module vectrix/vectors\n*/\n\"use strict\";\nimport * as matrices from \"./vectrix.matrices\";\nexport const {plus, minus, mut_plus, mut_minus} = matrices;\nlet flatten = matrices.flatten;\nlet {sqrt, min, max, acos} = Math;\n\n/*\n * All of the below is a dumb, slow workaround for the fact\n * that TypedArrays can't be used as prototypes. What we're \n * doing here is creating property aliases so that we can use \n * vectors somewhat like GLSL, for example: \n *\n * vec3([0,3,4]).zyx == vec3([4,3,0]); \n * \n * We do this programmatically because doing it be hand would \n * be even more tedious than this was. \n * \n * We precompute all the permutations of all the aliases and\n * their definitions, then throw them in the aliasesXd objects.\n * The individual vector factories then apply them during creation.\n * \n * Hopefully this isn't too slow because I spend a heck of a lot\n * of time making this happen.\n */\n\nexport const aliasCombos2d = [];\nexport const aliasCombos3d = [];\nexport const aliasCombos4d = [];\n\nexport const aliases2d = [\n\t{names:[\"x\"], i:0},\n\t{names:[\"y\"],i:1}\n];\n\nexport const aliases3d = [\n\t{names:[\"x\",\"r\"],i:0},\n\t{names:[\"y\",\"g\"],i:1},\n\t{names:[\"z\",\"b\"],i:2}\n];\n\nexport const aliases4d = [\n\t{names:[\"w\", \"a\"],i:3}\n].concat(aliases3d);\n\npermutations(\"xy\".split(\"\")).forEach((combo) => {\n\taliasCombos2d.push(combo);\n});\n\n[\"xz\",\"yz\",\"xyz\",\"rgb\"].forEach((props) => {\n\tpermutations(props.split(\"\")).forEach((combo) => {\n\t\taliasCombos3d.push(combo);\n\t});\n});\n\n[\"yxw\",\"zxw\",\"yzw\",\"xyzw\",\"rga\",\"rba\",\"gba\",\"rgba\"].forEach((props) => {\n\tpermutations(props.split(\"\")).forEach((combo) => {\n\t\taliasCombos4d.push(combo);\n\t});\n});\n\n/**\n * Util function to help generate permutations of property alias\n * sets\n * @private\n */\nfunction permutations(list) {\n\t// Empty list has one permutation\n\tif (list.length === 0) return [[]];\n\tvar result = [];\n\n\tfor (var i=0; i<list.length; i++) {\n\t\tvar copy = list.slice();\n\t\tvar head = copy.splice(i, 1);\n\t\tvar rest = permutations(copy);\n\t\tfor (var j=0; j<rest.length; j++) {\n\t\t\tvar next = head.concat(rest[j]);\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\treturn result;\n}\t\n\n/**\n * @private\n */\nfunction getAlias(i) {\n\t/* jshint validthis:true */\n\treturn this[i];\n}\n\n/**\n * Generic function wrapper for vector combo aliases (e.g. vector.xy)\n * @private\n */\nfunction getAliasCombo(factory, combo) {\n\tlet vals = combo.map((p) => this[p]);\n\treturn factory(vals);\n}\n\n/**\n * Defines vector aliases for a vector based on its length.\n * @private\n */\nfunction defineAliases(vec) {\n\tlet factory;\n\tlet map;\n\tlet combos;\n\tif(vec.length === 2) {\n\t\tmap = aliases2d;\n\t\tcombos = aliasCombos2d;\n\t}\n\telse if(vec.length === 3) {\n\t\tmap = aliases3d;\n\t\tcombos = aliasCombos2d.concat(aliasCombos3d);\n\t}\n\telse { // it's 4 because nothing else is supported or requested\n\t\tmap = aliases4d;\n\t\tcombos = aliasCombos2d.concat(aliasCombos3d, aliasCombos4d);\n\t}\n\tfor(let i = 0, len = map.length; i < len; ++i) {\n\t\tlet get = getAlias.bind(vec, map[i].i);\n\t\tfor(let n = 0, len = map[i].names.length; n < len; ++n) {\n\t\t\tObject.defineProperty(vec, map[i].names[n], {\n\t\t\t\tget:get\n\t\t\t});\n\t\t}\n\t}\n\tfor(let i = 0, len = combos.length; i < len; ++i) {\n\t\tswitch(combos[i].length) {\n\t\t\tcase 2:factory = create.vec2; break;\n\t\t\tcase 3:factory = create.vec3; break;\n\t\t\tcase 4:factory = create.vec4; break;\n\t\t}\n\t\tObject.defineProperty(vec, combos[i].join(\"\"), {\n\t\t\tget:getAliasCombo.bind(vec, factory, combos[i])\n\t\t});\n\t}\n}\n\n/**\n * Turns a vector function into a method by wrapping its result in a create()\n * statement.\n * @param {function} method\n * @param {vector} vector\n * @private\n */\nfunction asMethod(method, vector) {\n\treturn function() {\n\t\tlet res = method.apply(null, [vector].concat(Array.prototype.slice.apply(arguments)));\n\t\tif(!(res instanceof Float32Array)) return res;\n\t\tswitch(res.length) {\n\t\t\tcase 2: return wrap(create.vec2(res));\n\t\t\tcase 3: return wrap(create.vec3(res));\n\t\t\tcase 4: return wrap(create.vec4(res));\n\t\t\tdefault: return wrap(create(res.length, res));\n\t\t}\n\t}\n}\n\n/*\n * End ugly code for generating aliases.\n */\n\n\n/**\n * @private\n * used in [lerp](#lerp)\n */\nfunction lerp_element(a, b, t) {\n\treturn a+t*(b-a);\n}\n\n/**\n * @private\n * used in [cubic](#cubic)\n */\nfunction cubic_step(a, b, c, d, f0, f1, f2, f3) {\n\treturn a*f0 + b*f1 + c*f2 + d*f3;\n}\n\n/**\n * Copies values from second operand into first.\n * @example\n * let v = vec3(1,2,3);\n * let v2 = vec2(31,6);\n * copy(v, v2); // vec3(31,6,3);\n *\n * @mutates\n * @function mut_copy\n * @param {vector} a vector to copy into\n * @param {vector} b vector to copy from\n * @return {vector} a, with copied values\n */\nexport const mut_copy = (() => {\n\tlet i = 0|0, alen = 0|0, blen = 0|0;\n\treturn function mut_copy(a, b) {\n\t\tfor(i = 0, alen = a.length, blen = b.length;\n\t\t\ti < alen && i < blen; ++i) {\n\t\t\ta[i] = b[i];\n\t\t}\n\t\treturn a;\n\t}\n})();\n\n\n/**\n * Homogenous coordinates for a vector. \n *\n * @function homogenous\n * @param {vector} a input vector\n * @param {vector} out (optional) out parameter of one higher dimension than a\n * @return {matrix}\n */\nexport const homogenous = (function() {\n\tlet i = 0|0, len = 0|0;\n\treturn function homogenous(a, out = undefined) {\n\t\tlen = a.length;\n\t\tout = out||create(a.length+1);\n\t\tfor(i = 0|0; i < len; ++i) {\n\t\t\tout[i] = a[i];\n\t\t}\n\t\tout[i] = 1.0;\n\t\treturn out;\n\t}\n})();\n\n/**\n * Calculate the magnitude of a vector.\n * @example\n * magnitude(vec3(2,3,6)); // ~6.16\n *\n * @function magnitude\n * @param {vector} a operand\n * @return {float} magnitude of a\n */\nexport const magnitude = (function() {\n\tlet scratch = 0.0, cur = 0.0, i = 0|0, len = 0|0;\n\treturn function magnitude(a) {\n\t\tscratch = 0.0;\n\t\tfor(i = 0, len = a.length; i < len; ++i) {\n\t\t\tcur = a[i];\n\t\t\tscratch = scratch + cur * cur;\t\n\t\t}\n\t\treturn sqrt(scratch);\n\t}\n})();\n\n/**\n * Normalize a vector.\n *\n * @example\n * normalize(vector); // function style\n * vector.normalize(); // method style\n *\n * @function normalize\n * @param {vector} a vector to normalize\n * @param {vector} out (optional) a vector of the same dimensions as a\n * @return {vector}\n */\nexport const normalize = (function() {\n\tlet scale = 0.0, i = 0|0, len = 0|0;\n\treturn function normalize(a, out = undefined) {\n\t\tlen = a.length;\n\t\tout = out||create(len);\n\t\tscale = 1/magnitude(a);\n\t\t/*\n\t\tfor(i = 0|0; i < len; ++i) {\n\t\t\tcur = a[i]; // cut out one reference\n\t\t\tsum = sum+cur*cur;\n\t\t}\n\t\t*/\n\t\tfor(i = 0; i < len; ++i) {\n\t\t\tout[i] = a[i]*scale;\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [normalize](#normalize).\n * @function mut_normalize\n * @param {vector} a input vector\n * @return {matrix}\n */\nexport function mut_normalize(a) {\n\treturn normalize(a, a);\n}\n\n/**\n * Perform a linear interpolation between two vectors.\n * @function lerp\n * @param {vector} a first operand\n * @param {vector} b second operand\n * @param {float} t interval\n * @param {vector} out (optional) vector of same dimensions as a & b\n * @return {vector}\n */\nexport const lerp = (function() {\n\tlet i = 0|0, len = 0|0;\n\treturn function lerp(a, b, t, out) {\n\t\tlen = a.length;\n\t\tout = out||create(len);\n\t\tfor(i = 0|0; i < len; ++i) {\n\t\t\tout[i] = lerp_element(a[i], b[i], t);\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [lerp](#lerp).\n * @function lerp\n * @param {vector} a first operand\n * @param {vector} b second operand\n * @param {float} t interval\n * @param {vector} out (optional) vector of same dimensions as a & b\n * @return {vector}\n */\nexport function mut_lerp(a, b, t) {\n\treturn lerp(a, b, t, a);\n}\n\n/**\n * Perform a cubic bezier interpolation.\n * @function cubic\n * @param {vector} a start point\n * @param {vector} b first control point\n * @param {vector} c second control point\n * @param {vector} d end point\n * @param {float} t interval\n * @param {vector} out (optional) vector of same dimensions as start point \n * @return {vector}\n */\nexport const cubic = (function() {\n\tlet i = 0|0, len = 0|0, inv = 0.0, inv2 = 0.0, \n\t\t\tfs = 0.0, f0 = 0.0, f1 = 0.0, f2 = 0.0, f3 = 0.0;\n\treturn function cubic(a, b, c, d, t, out = undefined) {\n\t\tlen = a.length;\n\t\tout = out||create(len);\n\t\t/* parametric cubic bezier, faster than dec */\n\t\tinv = 1-t;\n\t\tinv2 = inv*inv;\n\t\tfs = t*t;\n\t\tf0 = inv2 * inv;\n\t\tf1 = 3 * t * inv2;\n\t\tf2 = 3 * fs * inv;\n\t\tf3 = fs * t;\n\t\tfor(i = 0|0; i < len; ++i) {\n\t\t\tout[i] = cubic_step(a[i], b[i], c[i], d[i], f0, f1, f2, f3);\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [cubic](#cubic).\n * @function mut_cubic\n * @param {vector} a start point\n * @param {vector} b first control point\n * @param {vector} c second control point\n * @param {vector} d end point\n * @param {float} t interval\n * @return {vector} interpolated a\n */\nexport function mut_cubic(a, b, c, d, t) {\n\treturn cubic(a, b, c, d, t, a);\n}\n\n\nexport const dot = (function() {\n\tlet i = 0|0, sum = 0.0;\n\treturn function dot(a, b) {\n\t\tsum = 0.0;\n\t\ti = a.length;\n\t\twhile(i--) {\n\t\t\tsum = sum + a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n})();\n\n/**\n * Vector product for matching vector types. Accepts vectors or generic arrays, \n * or defaults up to the matrix product if the vectors don't match (which supports\n * vector*matrix and scalar products).\n * @function times\n * @param {vector} a first operand\n * @param {vector|float} b second operand\n * @param {vector} out out vector \n * @return {matrix|float} product of a and b \n */\nexport var times = (function() {\n\tlet i = 0|0;//, len = 0|0;\n\treturn function(a, b, out) {\n\t\ti = a.length-1;\n\t\tif(typeof b === \"number\") {\n\t\t\tout = out||new Float32Array(i+1);\n\t\t\tfor(;i >= 0; --i) {\n\t\t\t\tout[i] = a[i] * b;\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\telse return dot(a, b);\n\t}\n})();\n\n/**\n * Mutating version of [times](#times). Note that a is mutated only when a is a vector\n * and b is a scalar.\n *\n * @function times\n * @param {vector} a first operand\n * @param {vector|float} b second operand\n * @return {matrix|float} mutated a, product of a and b \n */\nexport function mut_times(a, b) {\n\treturn times(a, b, a);\n}\n\n\n/**\n * Find the angle between two vectors in radians.\n * @function angle\n * @param {vector} a first operand\n * @param {vector} b second operand\n * @return {vector}\n */\nexport const angle = (function() {\n\tlet anorm, bnorm;\n\treturn function angle(a, b) {\n\t\tanorm = normalize(a);\n\t\tbnorm = normalize(b);\n\t\treturn acos(times(anorm, bnorm));\n\t}\n})();\n\n\n/**\n * Find the distance between two vectors.\n * @function distance\n * @param {vector} a first operand\n * @param {vector} b second operand\n * @return {float} distance\n */\nexport const distance = (function() {\n\tlet i = 0|0, len = 0|0, sum = 0.0, tmp = 0.0;\n\treturn function distance(a, b) {\n\t\tsum = 0.0;\n\t\tlen = a.length;\n\t\tfor(i = 0|0; i < len; ++i) {\n\t\t\ttmp = b[i] - a[i];\n\t\t\tsum = sum + tmp*tmp;\n\t\t}\n\t\treturn sqrt(sum);\n\t}\n})();\n\n\n/**\n * Vector cross products are technically only defined for 3D, but 2D can be\n * crossed with implicit z=0\n * @function cross\n * @param {vector} a first operand\n * @param {vector|float} b second operand\n * @param {vec3} out parameter\n * @return {Float32Array(3)} cross product\n */\nexport const cross = (function() {\n\tlet a0 = 0.0; let a1 = 0.0; let a2 = 0.0;\n\tlet b0 = 0.0; let b1 = 0.0; let b2 = 0.0;\n\treturn function cross(a, b, out) {\n\t\tif(a.length > 3 || b.length > 3 || a.length < 2 || b.length < 2) return undefined;\n\t\tout = out||create(3);\n\t\ta0 = a[0]; a1 = a[1]; a2 = a[2]||0.0;\n\t\tb0 = b[0]; b1 = b[1]; b2 = b[2]||0.0;\n\t\tout[0] = a1*b2 - a2*b1;\n\t\tout[1] = a2*b0 - a0*b2;\n\t\tout[2] = a0*b1 - a1*b0;\n\t\t/*\n\t\tmut_copy(scratcha, a);\n\t\tmut_copy(scratchb, b);\n\t\tif(a.length === 2) scratcha[2] = 0;\n\t\tif(b.length === 2) scratchb[2] = 0;\n\t\tout[0] = scratcha[1]*scratchb[2] - scratcha[2]*scratchb[1];\n\t\tout[1] = scratcha[2]*scratchb[0] - scratcha[0]*scratchb[2];\n\t\tout[2] = scratcha[0]*scratchb[1] - scratcha[1]*scratchb[0];\n\t\t*/\n\t\treturn out;\n\t}\n})();\n\n/**\n * Restricts scalar or vector values to a range.\n * @example\n * let v = vectors.create.vec3([-5,100, -22]); // vec3(-5,100, -22)\n * clamp(v, -10, 10); // vec3(-5, 10, -10);\n * let s = 23.0;\n * clamp(s, 0, 5); // 5\n *\n * @function clamp\n * @param {vector} a vector or scalar to clamp\n * @param {float} minv minimum value\n * @param {float} maxv maximum value\n * @param {vector} out output vector\n * @return {vector} clamped vector\n */\nexport var clamp = (() => {\n\tlet i = 0|0, len = 0|0;\n\tfunction clamp_s(a, minv, maxv) {\n\t\treturn max(min(a, maxv), minv)\n\t}\n\treturn function(a, minv, maxv, out) {\n\t\tif(typeof(a) === \"number\") return clamp_s(a, minv, maxv);\n\t\tout = out||new Float32Array(a.length);\n\t\tfor(i = 0, len = a.length; i < len; ++i) {\n\t\t\tout[i] = clamp(a[i], minv, maxv);\n\t\t}\n\t\treturn out;\n\t}\n})();\n\n/**\n * Mutating version of [clamp](#clamp).\n * @return {vector} the mutated vector\n */\nexport function mut_clamp(a, min, max) {\n\treturn clamp(a, min, max, a);\n}\n\n/**\n * Get a string representation of a vector.\n * @example\n * vectors.create.vec2([23,1]).toString(); // vec2(23.00, 1.00)\n * vectors.toString(vectors.create.vec2([23,1])); // vec2(23.00, 1.00)\n * @param {vector} a input vector\n * @return {string}\n */\nexport function toString(a) {\n\tlet strings = a.toArray().map((cur) => cur.toFixed(2));\n\treturn \"vec\"+a.length+\"(\"+strings.join(\", \")+\")\";\n}\n\n/**  \n * Creates a new vector. Note that vectors created directly with this function\n * will not have convenience aliases, meaning they're initialized faster but...\n * ah, less convenient. Can be supplied with an optional arraybuffer view and optional\n * offset to that view as the last or last two parameters.\n * @example\n * create(2); // vector[0,0]\n * create(2, 3.3, 3.2); // vector[3.3,3.2]\n * create(2, [3.3, 3.2]); // vector[3.3,3.2] from an array\n * create(2, 3.3, 3.2, new ArrayBuffer(2*4)); // vector[3.3,3.2] as view of ArrayBuffer\n * create(2, 3.3, 3.2, new ArrayBuffer(3*4), 4); // vector[3.3,3.2] as view of ArrayBuffer, offset by 4 bytes\n * create(2, [3.3, 3.2], new ArrayBuffer(3*4), 4); // vector[3.3,3.2] as view of ArrayBuffer, offset by 4 bytes, from an array\n *\n * @function create\n * @param {int} len [2...4] vector length\n * @param {mixed} args values in any combination of array-like and scalar values\n * @param {ArrayBuffer} buffer (optional) an array buffer to create the vector on \n * @param {offset} offset (optional) offset for the buffer, ignored if buffer is not supplied \n * @return {vector}\n */\nexport function create() {\n\tvar len = arguments.length, vec;\n\tif(len === 0) throw new Error(\"vectors.create requires at least one argument\");\n\telse if(len === 1) {\n\t\tvec = new Float32Array(arguments[0]);\n\t}\n\telse {\n\t\tlet params = Array.prototype.slice.apply(arguments), buffer, offset = 0, size = params.shift(), len = params.length;\n\t\tif((len > 0) && params[len-1] instanceof ArrayBuffer) { // supplied buffer, no offset\n\t\t\toffset = 0;\n\t\t\tbuffer = params.pop();\n\t\t}\n\t\telse if((len > 1) && params[len-2] instanceof ArrayBuffer) { // supplied buffer + offset\n\t\t\toffset = params.pop();\n\t\t\tbuffer = params.pop();\n\t\t}\n\t\tif(buffer !== undefined) {\n\t\t\tvec = new Float32Array(buffer, offset, size);\n\t\t}\n\t\telse vec = new Float32Array(size);\n\t\tif(params.length > 0) vec.set(flatten(params));\n\t}\n\treturn vec;\n}\n\n/**\n * Wraps a vector or array-like object with vector functions as methods.\n * @param {array-like} vec the vector to wrap\n * @return {vector} the wrapped vector\n */\nexport function wrap(vec) {\n\t// define vector-specific methods\n\tmatrices.wrap(vec, vec.length, 1);\n\tvec.toString = asMethod(toString, vec);\n\tvec.homogenous = asMethod(homogenous, vec);\n\tvec.times = asMethod(times, vec);\n\tvec.lerp = asMethod(lerp, vec);\n\tvec.cubic = asMethod(cubic, vec);\n\tvec.dot = asMethod(dot, vec);\n\tvec.clamp = asMethod(clamp, vec);\n\tvec.angle = angle.bind(null, vec);\n\tvec.magnitude = magnitude.bind(null, vec);\n\tvec.distance = distance.bind(null, vec);\n\tvec.normalize = asMethod(normalize, vec);\n\tvec.mut_normalize = asMethod(mut_normalize, vec);\n\tvec.mut_times = asMethod(mut_times, vec);\n\tvec.mut_lerp = asMethod(mut_lerp, vec);\n\tvec.mut_cubic = asMethod(mut_cubic, vec);\n\tvec.mut_clamp = asMethod(mut_clamp, vec);\n\tvec.mut_copy = asMethod(mut_copy, vec);\n\tif(vec.length === 2 || vec.length === 3) vec.cross = asMethod(cross, vec);\n\tdefineAliases(vec);\n\treturn vec;\n}\n\n/**\n * Creates a 2d vector. Curried version of [create](#create) with first argument presupplied.\n * @function create.vec2\n * @return {vector}\n */\nexport const vec2 = create.vec2 = create.bind(null, 2);\n/** \n * Creates a 3d vector. Curried version of [create](#create) with first argument presupplied.\n * @function create.vec3\n * @return {vector}\n */\nexport const vec3 = create.vec3 = create.bind(null, 3);\n/** \n * Creates a 4d vector. Curried version of [create](#create) with first argument presupplied.\n * @function create.vec4\n * @return {vector}\n */\nexport const vec4 = create.vec4 = create.bind(null, 4);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-vectrix/src/vectrix.vectors.js\n// module id = 9\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.COLOR_B = exports.COLOR_G = exports.COLOR_R = exports.BUFFER_LENGTH = undefined;\nexports.default = Photon;\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomix = require(\"../photonomix.util\");\n\nvar _photonomix2 = require(\"../photonomix.constants\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    times = _vectrix$vectors.times;\nvar mut_plus = vectrix.matrices.mut_plus;\nvar random = Math.random;\n\n\nvar I8 = 1;\nvar F32 = 4;\nvar O_POS = 0;\nvar O_VEL = F32 * 2;\nvar FLOAT_LENGTH = O_VEL + F32 * 2;\nvar O_COLOR = 0;\nvar O_LIFE = O_COLOR + I8;\nvar O_MASS = O_LIFE + I8;\nvar U8_LENGTH = O_MASS + I8;\nvar BUFFER_LENGTH = exports.BUFFER_LENGTH = FLOAT_LENGTH + U8_LENGTH + (F32 - (FLOAT_LENGTH + U8_LENGTH) % F32);\n\nvar COLOR_R = exports.COLOR_R = 0,\n    COLOR_G = exports.COLOR_G = 1,\n    COLOR_B = exports.COLOR_B = 2;\nfunction Photon(ipos, ivel, color) {\n\tvar _this = this;\n\n\tvar pool = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n\tvar buffer = void 0;\n\tthis.pool = pool;\n\tif (pool) {\n\t\tbuffer = pool.buffer;\n\t\tthis.offset = pool.allocate();\n\t} else {\n\t\tbuffer = new ArrayBuffer(BUFFER_LENGTH);\n\t\tthis.offset = 0;\n\t}\n\tthis.pos = vec2(ipos[0], ipos[1], buffer, O_POS + this.offset);\n\tthis.vel = vec2(ivel[0], ivel[1], buffer, O_VEL + this.offset);\n\tthis.intVals = new Uint8ClampedArray(buffer, FLOAT_LENGTH + this.offset, U8_LENGTH);\n\n\tObject.defineProperties(this, {\n\t\t\"color\": { get: function get() {\n\t\t\t\treturn _this.intVals[O_COLOR];\n\t\t\t}, set: function set(x) {\n\t\t\t\treturn _this.intVals[O_COLOR] = x;\n\t\t\t} },\n\t\t\"lifetime\": { get: function get() {\n\t\t\t\treturn _this.intVals[O_LIFE];\n\t\t\t}, set: function set(x) {\n\t\t\t\treturn _this.intVals[O_LIFE] = x;\n\t\t\t} },\n\t\t\"mass\": { get: function get() {\n\t\t\t\treturn _this.intVals[O_MASS];\n\t\t\t}, set: function set(x) {\n\t\t\t\treturn _this.intVals[O_MASS] = x;\n\t\t\t} }\n\t});\n\tthis.color = color;\n\tthis.lifetime = _photonomix2.PHOTON_LIFETIME;\n\tthis.size = _photonomix2.PHOTON_BASE_SIZE;\n\tthis.mass = 1;\n\tthis.pulse = ~~(_photonomix2.TARGET_FPS * random());\n}\n\nvar tmpvec = vec2(),\n    pos = void 0,\n    vel = void 0;\nPhoton.prototype.tick = function (surrounding, delta) {\n\tif (this.lifetime > 0) this.lifetime--;\n\tpos = this.pos;vel = this.vel;\n\tmut_plus(pos, times(vel, delta, tmpvec));\n\tmut_plus(vel, (0, _photonomix.drag)(vel, _photonomix2.GLOBAL_DRAG));\n};\n\nPhoton.prototype.destroy = function () {\n\tif (this.pool) this.pool.free(this.offset);else throw new Error(\"called photon.destroy, but photon has no pool\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/game/Photon.js\n// module id = 10\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.buttons = exports.keys = exports.pointer = undefined;\nexports.init = init;\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomixEvents = require(\"./photonomix.events.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar vec2 = vectrix.vectors.vec2;\n\n\nvar game = void 0; // game state\nvar controlEvents = new _photonomixEvents.Events();\n//let clickRegions = [];\n\nvar pointer = exports.pointer = {\n\tdown: vec2(),\n\tup: vec2(),\n\tmove: vec2()\n};\nvar keys = exports.keys = Array(256);\nvar buttons = exports.buttons = Array(5);\n\nfunction updateCursorState(event, v) {\n\tv[0] = event.clientX;\n\tv[1] = event.clientY;\n}\n\n/*\nfunction registerClickRegion(center, radius, callback) {\n\tclickRegions.push({center:vec2(center), radius:radius, callback:callback});\n}\n*/\n\nfunction init(env) {\n\tgame = env;\n\twindow.addEventListener(\"mousedown\", function mouseDown(event) {\n\t\tupdateCursorState(event, pointer.down);\n\t\tbuttons[event.button] = 1;\n\t\tcontrolEvents.fire(\"mousedown\");\n\t});\n\twindow.addEventListener(\"mouseup\", function mouseUp(event) {\n\t\tupdateCursorState(event, pointer.up);\n\t\tbuttons[event.button] = 0;\n\t\tcontrolEvents.fire(\"mouseup\");\n\t});\n\twindow.addEventListener(\"mousemove\", function mouseMove(event) {\n\t\tupdateCursorState(event, pointer.move);\n\t});\n\twindow.addEventListener(\"keydown\", function keyDown(event) {\n\t\tkeys[event.keyCode] = 1;\n\t});\n\twindow.addEventListener(\"keyup\", function keyDown(event) {\n\t\tkeys[event.keyCode] = 0;\n\t});\n\n\t/*\n controlEvents.on(\"mouseup\", function(position) {\n \tdist = distance(position, game.player.mouseDown);\n \tif(dist < region.radius) region.callback(region.center, dist);\n });\n \tcontrolEvents.on(\"mousedown\", function() {\n });\n \tcontrolEvents.on(\"mousemove\", function() {\n });\n */\n\n\t//registerClickRegion([0.0, 0.95], 0.1, game.actions.launchAntiGravitonCluster);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/photonomix.controls.js\n// module id = 11\n// module chunks = 0","\"use strict\";\nimport {flatten} from \"../pxene.util\";\nimport KeyState from \"./KeyState\";\nimport KeyMap from \"./KeyMap\";\n\nconst state = [\n];\n\nconst keyMaps = {\n}\n\n\n/**\n * Maps a label to one or more keys.\n * @example\n * ```javascript\n * let forward = pxene.controls.map(\"forward\", \"d\", \"rightArrow\");\n * ```\n * @param {string} label a label for the keymap\n * @param {string|Array} ...keys a list of keys to map\n * @return {KeyMap}\n */\nexport function map(label, ...keys) {\n\tconst map = getOrInitMap(label);\n\tkeys = flatten(keys);\n\tkeys.forEach(key => {\n\t\tconst ks = getOrInitKeyState(key);\n\t\tif(map.keys.indexOf(ks) == -1) map.keys.push(ks)\n\t});\n\treturn map;\n}\n\n/**\n * Removes a key mapping, returning the modified {@link KeyMap}.\n * @param {string} label the key map's label\n * @param {string} key the [key name]{@link KeyState} to remove\n * @return {KeyMap|undefined} undefined if the KeyMap for the label didn't exist\n */\nexport function unmap(label, key) {\n\tif(keyMaps[label]) {\n\t\tlet index = keyMaps[label].keys.indexOf(lookupKeyState(key));\n\t\tif(index) keyMaps.keys.splice(index, 1);\n\t}\n\treturn keyMaps[label];\n}\n\n/**\n * Finds a keyState by [key name]{@link KeyMap}, initializing a new one if necessary.\n * @param {string} key the key name\n * @return {KeyState}\n */\nfunction getOrInitKeyState(key) {\n\tkey = key.toLowerCase();\n\tlet ks = lookupKeyState(key);\n\tif(ks === undefined) {\n\t\tks = new KeyState(key);\n\t\tstate.push(ks);\n\t}\n\treturn ks;\n}\n\n/**\n * Finds a keyMap by label, initializing a new one if necessary.\n * @param {string} label the keymap label\n * @return {KeyMap}\n */\nfunction getOrInitMap(label) {\n\tlet mapped = lookupMap(label);\n\tif(mapped === undefined) {\n\t\tmapped = new KeyMap(label);\n\t\tkeyMaps[label] = mapped;\n\t}\n\treturn mapped;\n}\n\n/**\n * Looks up a KeyMap by label.\n * @param {string} label the keymap label\n * @return {KeyMap|undefined}\n */\nexport function lookupMap(label) {\n\treturn keyMaps[label];\n}\n\n/**\n * Looks up a KeyState by [key name]{@link KeyState}.\n */\nexport function lookupKeyState(key) {\n\tkey = key.toLowerCase();\n\treturn state.filter(ks => ks.key === key)[0]\n}\n\n/**\n * Handles keydown events.\n */\nfunction down(ev) {\n\tconst time = Date.now();\n\tconst ks = lookupKeyState(ev.key);\n\tif(ks && ks.lastUp >= ks.lastDown) { // ignore key repeats\n\t\tks.down = true;\n\t\tks.lastDown = time; \n\t}\n}\n\n/**\n * Handles keyup events.\n */\nfunction up(ev) {\n\tconst time = Date.now();\n\tconst ks = lookupKeyState(ev.key);\n\tif(ks) {\n\t\tks.down = false;\n\t\tks.lastUp = time;\n\t}\n}\n\n/**\n * When the window blurs we lose track of key events, so toggle all keys off.\n */\nfunction blur() {\n\tconst time = Date.now();\n\tstate.forEach(ks => {\n\t\tks.down = false;\n\t\tks.lastUp = time;\n\t});\n}\n\nexport function init() {\n\twindow.addEventListener(\"keydown\", down); \n\twindow.addEventListener(\"keyup\", up); \n\twindow.addEventListener(\"blur\", blur);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/controls/index.js\n// module id = 12\n// module chunks = 0","\"use strict\";\nimport * as util from \"./pxene.display.util.js\";\nimport * as buffers from \"./pxene.display.buffers\";\nimport * as events from \"./pxene.events\";\nimport * as ui from \"./pxene.display.ui\";\nexport {buffers, ui, util};\nimport * as constants from \"./pxene.constants\";\nimport {evenNumber} from \"./pxene.util\";\nlet {min, max} = Math;\nlet AUTO_FULLSCREEN = false;\n\nlet startTime; // time game started\nlet interval = 0;\nlet elapsed = 0;\nlet frameCount = 0; // running total of drawn frames\nlet animating = false; // whether the game is currently running animation loop\nlet container; // display container \nlet fullscreen = false; // whether the game is in fullscreen mode\nlet lastFrame = 0;\nlet frameCallback;\nconst bufferList = [];\nexport const buffersByLabel = {};\nlet compositeBuffer;\n\nexport const props = {\n\twidth:0,\n\theight:0,\n\tpixelRatio:1,\n\torientation:0,\n\taspect:0,\n\tminDimension:0,\n\tmaxDimension:0,\n\tevents:new events.Events()\n}\n\nexport const timing = {\n\tget frameCount() {return frameCount},\n\tget startTime() {return startTime},\n\tget lastFrame() {return lastFrame},\n\tget elapsed() {return elapsed},\n\tget interval() {return interval}\n}\n\n/**\n * Using this checks and avoids altering the canvas context state machine if unnecessary,\n * which theoretically saves a little time.\n */\nexport function updateCompositeOperation(ctx, op) {\n\tif(ctx.globalCompositeOperation !== op) ctx.globalCompositeOperation = op;\n}\n\n/**\n * Toggles fullscreen on.\n * Code from Mozilla Developer Network.\n */\nfunction toggleFullScreen() {\n\tif(fullscreen) return;\n\tfullscreen = true;\n  if(!document.fullscreenElement &&    // alternative standard method\n      !document.mozFullScreenElement && \n\t\t\t!document.webkitFullscreenElement && \n\t\t\t!document.msFullscreenElement) {  // current working methods\n    if(document.documentElement.requestFullscreen)\n\t\t\tdocument.documentElement.requestFullscreen();\n    else if (document.documentElement.msRequestFullscreen)\n      document.documentElement.msRequestFullscreen();\n    else if (document.documentElement.mozRequestFullScreen)\n      document.documentElement.mozRequestFullScreen();\n    else if (document.documentElement.webkitRequestFullscreen)\n      document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n\t\tprops.events.fire(\"fullscreen-on\");\n  } \n\telse {\n    if (document.exitFullscreen) document.exitFullscreen();\n    else if (document.msExitFullscreen) document.msExitFullscreen();\n    else if (document.mozCancelFullScreen) document.mozCancelFullScreen();\n    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();\n\t\tprops.events.fire(\"fullscreen-off\");\n  }\n}\n\n/**\n * Turns fullscreen off.\n */\nfunction fullscreenOff(ev) {\n\tev.preventDefault();\n\tif(document.webkitIsFullScreen || \n\t   document.mozIsFullScreen || \n\t\t document.msIsFullScreen) fullscreen = true;\n\telse fullscreen = false;\n\treturn false;\n}\n\n/**\n * Updates screen ratio.\n */\nfunction updateProperties() {\n\tcompositeBuffer.width  = props.width  = evenNumber(container.clientWidth);\n\tcompositeBuffer.height = props.height = evenNumber(container.clientHeight);\n\tprops.orientation = props.width > props.height?0:1;\n\tprops.minDimension = min(props.width, props.height);\n\tprops.maxDimension = max(props.width, props.height);\n\t// @todo review this, it probably needs better handling\n\tbufferList.forEach(buffer => {\n\t\tbuffer.width = ~~(props.width/props.pixelRatio);\n\t\tbuffer.height = ~~(props.height/props.pixelRatio);\n\t});\n\tprops.events.fire(\"resize\");\n}\n\n\n/**\n * Main animation loop.\n */\nfunction animate() {\n\trequestAnimationFrame(animate);\n\ttry {\n\t\tlet now = Date.now();\n\t\t\telapsed = now - lastFrame;\n\t\t\tif(elapsed > interval) {\n\t\t\t\tlastFrame = now - (elapsed % interval);\n\t\t\t\tframeCount++;\n\t\t\t\tframeCallback(buffersByLabel);\n\t\t\t\tbuffers.composite(bufferList, compositeBuffer, props);\n\t\t\t}\n\t\t}\n\tcatch(e) {\n\t\tconsole.error(\"Crappy uncaught error in animation loop is crappy\");\n\t}\n}\n\nfunction initBuffers(bufferDescriptions) {\n\tfor(let i = 0, len = bufferDescriptions.length; i < len; ++i) {\n\t\tlet bufData = bufferDescriptions[i];\n\t\tlet buffer = new buffers.DrawBuffer(bufData.compositeMethod, bufData.scaleMethod);\n\t\tbuffer.id = bufData.label;\n\t\tbufferList.push(buffer);\n\t\tbuffersByLabel[bufData.label] = buffer;\n\t}\n}\n\n/**\n * Initializes game environment.\n */\nexport function init(config) {\n\tprops.pixelRatio = config.pixelRatio || props.pixelRatio;\n\tcontainer = document.querySelector(config.container);\n\tcontainer.classList.add(\"2d\");\n\tcompositeBuffer = new buffers.CompositeBuffer(container);\n\tcontainer.width = compositeBuffer.width  = evenNumber(container.clientWidth);\n\tcontainer.height = compositeBuffer.height = evenNumber(container.clientHeight);\n\tinitBuffers(config.bufferDescriptions);\n\tupdateProperties();\n\tframeCallback = config.frameCallback;\n\twindow.addEventListener(\"resize\", updateProperties);\n\tAUTO_FULLSCREEN = config.fullscreen;\n\tif(AUTO_FULLSCREEN) {\n\t\tcontainer.addEventListener(\"click\", toggleFullScreen);\n\t\tdocument.addEventListener(\"fullscreenchange\", fullscreenOff);\n\t\tdocument.addEventListener(\"mozfullscreenchange\", fullscreenOff);\n\t\tdocument.addEventListener(\"msfullscreenchange\", fullscreenOff);\n\t\tdocument.addEventListener(\"webkitfullscreenchange\", fullscreenOff);\n\t}\n\tstartTime = Date.now();\n\tlastFrame = startTime;\n\tinterval = 1000 / constants.TARGET_FPS;\n\tif(!animating) requestAnimationFrame(animate);\n\tanimating = true;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.display.js\n// module id = 13\n// module chunks = 0","\"use strict\";\n\n/**\n * *Very* simple event object.\n */\nexport function Events() {\n\tthis.queue = {};\n\treturn this;\n}\n\nEvents.prototype.on = function(event, callback) {\n\tif(this.queue[event] === undefined) this.queue[event] = [];\n\tthis.queue[event].push(callback);\n}\n\nEvents.prototype.fire = (function() {\n\tlet i, len;\n\treturn function(event, params) {\n\t\tif(this.queue[event] === undefined) return;\n\t\tfor(i = 0, len = this.queue[event].length; i < len; ++i) {\n\t\t\tthis.queue[event][i].call(params);\n\t\t}\n\t}\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.events.js\n// module id = 14\n// module chunks = 0","/**\nMaster module for vectrix. See individual modules for documentation.\n@module vectrix\n */\n\"use strict\";\nimport * as _v from \"./vectrix.vectors\";\nimport * as _m from \"./vectrix.matrices\";\nimport * as _q from \"./vectrix.quaternions\";\n\nexport const vectors = _v;\nexport const matrices = _m;\nexport const quaternions = _q;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-vectrix/src/vectrix.js\n// module id = 15\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.initMoteSpriteSheet = initMoteSpriteSheet;\nexports.createMoteCenterSprite = createMoteCenterSprite;\nexports.getMoteSprite = getMoteSprite;\nexports.getColorString = getColorString;\nexports.colorIndex = colorIndex;\nexports.createMoteSprite = createMoteSprite;\nexports.createPhotonSprite = createPhotonSprite;\nexports.createMarkerHitSprite = createMarkerHitSprite;\nexports.createVoidSprite = createVoidSprite;\nexports.createEmitterSprite = createEmitterSprite;\nexports.createGameSpaceMask = createGameSpaceMask;\nvar colorStrings = exports.colorStrings = Array(4096);\nvar moteSpriteSheetCanvas = exports.moteSpriteSheetCanvas = undefined;\nvar MASK_R = 0xf00;\nvar MASK_G = 0x0f0;\nvar MASK_B = 0x00f;\n\nvar moteSprites;\nvar moteMaskCanvas;\nvar moteSpriteSheetContext;\nvar moteMaskContext;\nvar moteSpriteScale = 0;\nvar moteSpriteSize = 0;\nvar motePixelSize = 0;\nvar moteTmpCanvas;\nvar moteTmpContext;\n\nfunction initMoteSpriteSheet(scale, size) {\n\tmoteSpriteScale = scale;\n\tmoteSpriteSize = size;\n\tmotePixelSize = scaleSprite(moteSpriteScale, moteSpriteSize);\n\n\tmoteTmpCanvas = document.createElement(\"canvas\");\n\tmoteTmpCanvas.width = moteTmpCanvas.height = motePixelSize;\n\tmoteTmpContext = moteTmpCanvas.getContext(\"2d\");\n\n\texports.moteSpriteSheetCanvas = moteSpriteSheetCanvas = document.createElement(\"canvas\");\n\tmoteSpriteSheetCanvas.width = moteSpriteSheetCanvas.height = motePixelSize * 64;\n\tmoteSpriteSheetContext = moteSpriteSheetCanvas.getContext(\"2d\");\n\n\tmoteMaskCanvas = document.createElement(\"canvas\");\n\tmoteMaskCanvas.width = moteMaskCanvas.height = motePixelSize;\n\tmoteMaskContext = moteMaskCanvas.getContext(\"2d\");\n\n\tmoteSprites = Array(4096);\n\tvar g = moteMaskContext.createRadialGradient(motePixelSize / 2, motePixelSize / 2, motePixelSize / 2, motePixelSize / 2, motePixelSize / 2, 0);\n\tg.addColorStop(1, \"rgba(255,255,255,1.0\");\n\tg.addColorStop(0.7, \"rgba(255,255,255,0.5)\");\n\tg.addColorStop(0.1, \"rgba(255,255,255,0.0)\");\n\tmoteMaskContext.fillStyle = g;\n\tmoteMaskContext.fillRect(0, 0, motePixelSize, motePixelSize);\n\tfor (var i = 0; i < 4096; ++i) {\n\t\tcolorStrings[i] = \"rgb(\" + ((i & MASK_R) >> 4) + \",\" + (i & MASK_G) + \",\" + ((i & MASK_B) << 4) + \")\";\n\t\tmoteSprites[i] = createMoteSprite(i, colorStrings[i]);\n\t}\n}\n\nfunction createMoteCenterSprite() {\n\tvar pixelSize = motePixelSize;\n\tvar w = motePixelSize;\n\tvar h = motePixelSize;\n\tvar px = 0;\n\tvar py = 0;\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.width = w;\n\tcanvas.height = h;\n\tvar context = canvas.getContext(\"2d\");\n\tcontext.globalCompositeOperation = \"copy\";\n\tcontext.drawImage(moteMaskCanvas, 0, 0, w, h);\n\tcontext.globalCompositeOperation = \"source-in\";\n\tcontext.fillStyle = \"rgba(255,255,255,0.25)\";\n\tcontext.fillRect(0, 0, w, h);\n\treturn {\n\t\tcanvas: canvas,\n\t\tcontext: context,\n\t\tpixelSize: pixelSize,\n\t\tsw: pixelSize,\n\t\tsh: pixelSize,\n\t\tsx: px,\n\t\tsy: py\n\t};\n}\n\nfunction getMoteSprite(index) {\n\treturn moteSprites[index];\n}\n\nfunction getColorString(index) {\n\treturn colorStrings[index];\n}\n\nfunction colorIndex(r, g, b) {\n\treturn (r >> 4 << 8) + (g >> 4 << 4) + (b >> 4);\n}\n\nfunction createMoteSprite(index, color) {\n\tvar pixelSize = motePixelSize;\n\tvar w = motePixelSize;\n\tvar h = motePixelSize;\n\tvar y = index % 64;\n\tvar x = (index - y) / 64;\n\tvar py = y * motePixelSize;\n\tvar px = x * motePixelSize;\n\tmoteTmpContext.globalCompositeOperation = \"copy\";\n\tmoteTmpContext.drawImage(moteMaskCanvas, 0, 0, w, h);\n\tmoteTmpContext.globalCompositeOperation = \"source-in\";\n\tmoteTmpContext.fillStyle = color;\n\tmoteTmpContext.fillRect(0, 0, w, h);\n\tmoteSpriteSheetContext.drawImage(moteTmpCanvas, px, py, w, h);\n\treturn {\n\t\tcanvas: moteSpriteSheetCanvas,\n\t\tcontext: moteSpriteSheetContext,\n\t\tpixelSize: pixelSize,\n\t\tsw: pixelSize,\n\t\tsh: pixelSize,\n\t\tsx: px,\n\t\tsy: py\n\t};\n}\n\nfunction scaleSprite(scale, spriteSize) {\n\treturn ~~(scale * spriteSize);\n}\n\n/**\n * Creates a photon sprite.\n */\nfunction createPhotonSprite(scale, spriteSize, color) {\n\tvar pixelSize = 17; //scaleSprite(scale, spriteSize);\n\tvar hps = ~~(pixelSize / 2);\n\tvar qps = ~~(pixelSize / 4);\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.width = canvas.height = pixelSize;\n\tvar context = canvas.getContext(\"2d\");\n\tvar g = void 0;\n\t/*\n let mask = document.createElement(\"canvas\");\n mask.width = mask.height = pixelSize; \n let maskCtx = mask.getContext(\"2d\");\n */\n\t/*\n g = maskCtx.createRadialGradient(hps, hps, hps, hps, hps, 0);\n g.addColorStop(0.0, \"rgba(255,255,255,0.0)\");\n g.addColorStop(0.09, \"rgba(255,255,255,1.0)\");\n maskCtx.fillStyle = g;\n maskCtx.fillRect(0, 0, pixelSize, pixelSize);\n context.drawImage(mask, -hps, -hps, pixelSize, pixelSize);\n context.drawImage(mask, hps, hps, pixelSize, pixelSize);\n context.drawImage(mask, hps, -hps, pixelSize, pixelSize);\n context.drawImage(mask, -hps, hps, pixelSize, pixelSize);\n */\n\tg = context.createRadialGradient(hps, hps, hps, hps, hps, 0);\n\tg.addColorStop(0.7, color);\n\tg.addColorStop(1.0, \"white\");\n\tcontext.globalCompositeOperation = \"source-over\";\n\tcontext.beginPath();\n\tcontext.moveTo(hps, 0);\n\tcontext.quadraticCurveTo(hps, hps, 0, hps);\n\tcontext.quadraticCurveTo(hps, hps, hps, pixelSize);\n\tcontext.quadraticCurveTo(hps, hps, pixelSize, hps);\n\tcontext.quadraticCurveTo(hps, hps, hps, 0);\n\tcontext.fillStyle = g;\n\tcontext.fill();\n\tcontext.closePath();\n\tcontext.beginPath();\n\tcontext.moveTo(hps, qps);\n\tcontext.lineTo(hps, pixelSize - qps);\n\tcontext.moveTo(qps, hps);\n\tcontext.lineTo(pixelSize - qps, hps);\n\tcontext.strokeStyle = \"white\";\n\tcontext.lineWidth = 1;\n\tcontext.stroke();\n\tcontext.closePath();\n\t//context.fillRect(0, 0, pixelSize, pixelSize);\n\treturn {\n\t\tcanvas: canvas,\n\t\tcontext: context,\n\t\tpixelSize: pixelSize,\n\t\tw: pixelSize,\n\t\th: pixelSize\n\t};\n}\n\n/**\n * Creates a hit marker sprite.\n */\nfunction createMarkerHitSprite(scale, spriteSize) {\n\tvar pixelSize = scaleSprite(scale, spriteSize);\n\tvar hps = ~~(pixelSize / 2);\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.width = canvas.height = pixelSize;\n\tvar context = canvas.getContext(\"2d\");\n\tvar g = context.createRadialGradient(hps, hps, hps, hps, hps, 0);\n\tg.addColorStop(0.0, \"rgba(255,255,255,0.0)\");\n\tg.addColorStop(0.05, \"rgba(255,255,255,0.4)\");\n\tg.addColorStop(0.09, \"rgba(255,255,255,0.35)\");\n\tg.addColorStop(0.55, \"rgba(255,255,255,0.0)\");\n\tcontext.fillStyle = g;\n\tcontext.fillRect(0, 0, pixelSize, pixelSize);\n\treturn {\n\t\tcanvas: canvas,\n\t\tcontext: context,\n\t\tpixelSize: pixelSize,\n\t\tw: pixelSize,\n\t\th: pixelSize\n\t};\n}\n\n/**\n * Creates a void sprite.\n */\nfunction createVoidSprite(scale, spriteSize) {\n\tvar pixelSize = scaleSprite(scale, spriteSize);\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.width = canvas.height = pixelSize;\n\tvar ctx = canvas.getContext(\"2d\");\n\tvar g = ctx.createRadialGradient(pixelSize / 2, pixelSize / 2, pixelSize / 2, pixelSize / 2, pixelSize / 2, 0);\n\tg.addColorStop(1, \"rgba(0,0,0,1.0)\");\n\tg.addColorStop(0.50, \"rgba(0,0,0,1.0)\");\n\tg.addColorStop(0.479, \"rgba(0,0,0,0.99)\");\n\tg.addColorStop(0.442, \"rgba(0,0,0,0.98)\");\n\tg.addColorStop(0.44, \"rgba(255,255,255,0.95)\");\n\tg.addColorStop(0.43, \"rgba(255,255,255,0.95)\");\n\tg.addColorStop(0.41, \"rgba(255,255,255,0.39)\");\n\tg.addColorStop(0.37, \"rgba(255,255,255,0.29)\");\n\tg.addColorStop(0.36, \"rgba(255,255,255,0.32)\");\n\tg.addColorStop(0.34, \"rgba(255,255,255,0.31)\");\n\tg.addColorStop(0.30, \"rgba(255,255,255,0.35)\");\n\tg.addColorStop(0.28, \"rgba(255,255,255,0.39)\");\n\tg.addColorStop(0.26, \"rgba(255,255,255,0.35)\");\n\tg.addColorStop(0.23, \"rgba(255,255,255,0.30)\");\n\tg.addColorStop(0.21, \"rgba(255,255,255,0.26)\");\n\tg.addColorStop(0.20, \"rgba(255,255,255,0.31)\");\n\tg.addColorStop(0.19, \"rgba(255,255,255,0.34)\");\n\tg.addColorStop(0.17, \"rgba(255,255,255,0.29)\");\n\tg.addColorStop(0.16, \"rgba(255,255,255,0.21)\");\n\tg.addColorStop(0.15, \"rgba(255,255,255,0.19)\");\n\tg.addColorStop(0.14, \"rgba(255,255,255,0.15)\");\n\tg.addColorStop(0.10, \"rgba(255,255,255,0.09)\");\n\tg.addColorStop(0.09, \"rgba(255,255,255,0.15)\");\n\tg.addColorStop(0.07, \"rgba(255,255,255,0.12)\");\n\tg.addColorStop(0.05, \"rgba(255,255,255,0.09)\");\n\t/*\n g.addColorStop(0.43, \"rgba(128,128,128,0.4)\");\n g.addColorStop(0.41, \"rgba(192,192,192,0.6)\");\n g.addColorStop(0.4, \"rgba(192,192,192,0.4)\");\n g.addColorStop(0.37, \"rgba(192,192,192,0.3)\");\n g.addColorStop(0.15, \"rgba(0,0,0,0.2)\");\n */\n\tg.addColorStop(0.0, \"rgba(0,0,0,0.0)\");\n\tctx.fillStyle = g;\n\tctx.fillRect(0, 0, pixelSize, pixelSize);\n\treturn {\n\t\tcanvas: canvas,\n\t\tcontext: ctx,\n\t\tw: pixelSize,\n\t\th: pixelSize,\n\t\tpixelSize: pixelSize\n\t};\n}\n\n/**\n * Creates an emitter sprite.\n */\nfunction createEmitterSprite(scale, spriteSize) {\n\tvar pixelSize = scaleSprite(scale, spriteSize);\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.width = canvas.height = pixelSize;\n\tvar ctx = canvas.getContext(\"2d\");\n\tvar g = ctx.createRadialGradient(pixelSize / 2, pixelSize / 2, pixelSize / 2, pixelSize / 2, pixelSize / 2, 0);\n\tg.addColorStop(1, \"rgba(255,255,255,0.3)\");\n\tg.addColorStop(0.78, \"rgba(255,255,255,0.3)\");\n\tg.addColorStop(0.58, \"rgba(255,255,255,0.22)\");\n\tg.addColorStop(0.48, \"rgba(255,255,255,0.17)\");\n\tg.addColorStop(0.44, \"rgba(255,255,255,0.22)\");\n\tg.addColorStop(0.40, \"rgba(255,255,255,0.19)\");\n\tg.addColorStop(0.2, \"rgba(255,255,255,0.09)\");\n\tg.addColorStop(0.1, \"rgba(255,255,255,0.0)\");\n\tctx.fillStyle = g;\n\tctx.fillRect(0, 0, pixelSize, pixelSize);\n\treturn {\n\t\tcanvas: canvas,\n\t\tcontext: ctx,\n\t\tw: pixelSize,\n\t\th: pixelSize,\n\t\tpixelSize: pixelSize\n\t};\n}\n\nfunction createGameSpaceMask() {\n\tvar pixelSize = 1000;\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.width = canvas.height = pixelSize;\n\tvar ctx = canvas.getContext(\"2d\");\n\tvar g = ctx.createRadialGradient(pixelSize / 2, pixelSize / 2, pixelSize / 2, pixelSize / 2, pixelSize / 2, 0);\n\tg.addColorStop(1, \"rgba(0,0,0,0.0)\");\n\tg.addColorStop(0.05, \"rgba(0,0,0,0.0)\");\n\tg.addColorStop(0.0, \"rgba(255,255,255,1.0)\");\n\tctx.fillStyle = g;\n\tctx.fillRect(0, 0, pixelSize, pixelSize);\n\treturn {\n\t\tcanvas: canvas,\n\t\tcontext: ctx,\n\t\tw: pixelSize,\n\t\th: pixelSize,\n\t\tpixelSize: pixelSize\n\t};\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/draw/sprites.js\n// module id = 16\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.BUFFER_LENGTH = exports.ACT_LINK = exports.ACT_ATTACK = exports.ACT_AVOID = exports.ACT_CHASE = exports.ACT_SEARCH = exports.ACT_IDLE = undefined;\nexports.default = Mote;\n\nvar _photonomix = require(\"../photonomix.constants\");\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomix2 = require(\"../photonomix.util\");\n\nvar _Photon = require(\"./Photon\");\n\nvar _Photon2 = _interopRequireDefault(_Photon);\n\nvar _Void = require(\"./Void\");\n\nvar _Void2 = _interopRequireDefault(_Void);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar random = Math.random,\n    max = Math.max,\n    min = Math.min,\n    floor = Math.floor,\n    ceil = Math.ceil,\n    sin = Math.sin;\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    times = _vectrix$vectors.times,\n    mut_clamp = _vectrix$vectors.mut_clamp,\n    magnitude = _vectrix$vectors.magnitude,\n    distance = _vectrix$vectors.distance,\n    mut_copy = _vectrix$vectors.mut_copy,\n    mut_times = _vectrix$vectors.mut_times;\nvar _vectrix$matrices = vectrix.matrices,\n    plus = _vectrix$matrices.plus,\n    mut_plus = _vectrix$matrices.mut_plus;\n\nvar clamp = mut_clamp;\n// Center of the playfield is at 0,0 (ranging from -1 to 1 on X and Y axis)\nvar POS_C = vec2(0.0, 0.0);\n// activity type constants\nvar ACT_IDLE = exports.ACT_IDLE = 0;\nvar ACT_SEARCH = exports.ACT_SEARCH = 1;\nvar ACT_CHASE = exports.ACT_CHASE = 2;\nvar ACT_AVOID = exports.ACT_AVOID = 3;\nvar ACT_ATTACK = exports.ACT_ATTACK = 4;\nvar ACT_LINK = exports.ACT_LINK = 5;\n\n// twiddle to slightly offset the values, avoids divide by zero and other errors\n// inherent to acceleration, friction, drag and gravity equations\n(0, _photonomix2.twiddleVec)(POS_C);\n// relative color values derived from a Mote's photons, used to produce color string\n// for rendering\n\n// various consts below are indexes and byte counts for mote data\n// byte length of these value types\nvar I8 = 1;\nvar F32 = 4;\n\n// uint8 values = photons[3]\nvar U8_PHO = 0,\n    U8_COL = U8_PHO + I8 * 3,\n    U8_VAL_LENGTH = U8_COL + I8 * 3,\n    I8_BYTE_OFFSET = U8_VAL_LENGTH;\n// int8 values =  dying, pregnant, injured, lastMeal, pulse\nvar I8_DYING = 0,\n    I8_PREG = I8_DYING + I8,\n    I8_INJURED = I8_PREG + I8,\n    I8_LAST_INJURY = I8_INJURED + I8,\n    I8_MEAL = I8_LAST_INJURY + I8,\n    I8_UPD = I8_MEAL + I8,\n    I8_PULSE = I8_UPD + I8,\n    I8_ACT = I8_PULSE + I8,\n    I8_VAL_LENGTH = I8_ACT + I8,\n    INT_VAL_LENGTH = U8_VAL_LENGTH + I8_VAL_LENGTH;\n\n// float32 values = p[3], v[3], color[4], size, sizeMin, sizeMax, speed, sight, agro, fear, potential, resistance\n// from here on, increments of value * 4\n// vectors\nvar VEC_BYTE_OFFSET = INT_VAL_LENGTH + (F32 - INT_VAL_LENGTH % F32),\n    // float32 offsets must be multiples of 4\nF32_POS = 0,\n    F32_VEL = F32_POS + 2,\n    F32_RAT = F32_VEL + 2,\n    F32_PREF = F32_RAT + 3,\n    VEC_VAL_LENGTH = F32_PREF + 3;\n\nvar F32_BYTE_OFFSET = VEC_BYTE_OFFSET + VEC_VAL_LENGTH * F32,\n\n// scalars\nF32_SIZE = 0,\n    F32_SIZE_MIN = F32_SIZE + 1,\n    F32_SIZE_MAX = F32_SIZE_MIN + 1,\n    F32_SPEED = F32_SIZE_MAX + 1,\n    F32_SIGHT = F32_SPEED + 1,\n    F32_AGRO = F32_SIGHT + 1,\n    F32_FEAR = F32_AGRO + 1,\n    F32_POTENTIAL = F32_FEAR + 1,\n    F32_RESISTANCE = F32_POTENTIAL + 1,\n    F32_MASS = F32_RESISTANCE + 1,\n    FLOAT_VAL_LENGTH = F32_MASS + 1;\n\nvar BUFFER_LENGTH = exports.BUFFER_LENGTH = F32_BYTE_OFFSET + FLOAT_VAL_LENGTH * F32;\n\n// scratch vectors used in various functions\nvar scratch1 = vec2(),\n    scratch2 = vec2();\n\n/**\n * Constructor for Motes.\n * @param {Float32Array(3)} photons initial photons (0-255, R, G, B)\n * @param {vec2} pos initial position\n * @param {Float} bSpeed (optional) base acceleration: inheritance and predesigned motes \n * @param {Float} bSight (optional) base vision radius: inheritance and predesigned motes \n * @param {Float} bAgro (optional) base aggressiveness: inheritance and predesigned motes \n * @param {Float} bFear (optional) base fearfulness: inheritance and predesigned motes \n * @param {BufferPool} pool (optional) buffer pool to build the mote on\n * @property {vec2} pos position vector\n * @property {vec2} vel velocity vector\n * @property {Uint8} r red photon value (setter updates values and derived props)\n * @property {Uint8} g green photon value (setter updates value and derived props)\n * @property {Uint8} b blue photon value (setter updates value and derived props)\n * @property {string} color_string rgba color string, used for drawing in 2d\n * @property {Int8} dying counter from 1 to DEATH_THRESHOLD when a mote is dying\n * @property {Int8} pregnant coundown from PREGNANT_DURATION when a mote is pregnant\n * @property {Int8} injured injury counter, counts down in mote.bleed\n * @property {Int8} lastInjury strength of most recent injury taken\n * @property {Int8} pulse frame offset for pulse animation\n * @property {Int8} lastMeal color value for last meal (see R, G, B constants)\n * @property {Int8} action action choice in relation to target \n * @property {Float32} speed derived acceleration speed based on Mote properties\n * @property {Float32} sight derived vision radius based on Mote properties \n * @property {Float32} agro derived aggression factor based on Mote properties \n * @property {Float32} fear derived fearfulness factor based on Mote properties \n * @property {Float32} potential accumulated charge potential\n * @property {Float32} resistance accumulated resistance to charge\n * @property {Float32} size derived size radius as fraction of screen size\n * @property {Float32} sizeMin minimum size the mote can reach as it shrinks\n * @property {Float32} sizeMax maximum size the mote can reach as it grows\n * @property {UintClamped8Array} photons current photon values (R, G, B)\n * @property {UintClamped8Array} color current mote color (R, G, B)\n * @property {Int8Array} intVals direct access to integer value array (for debug)\n * @property {Float32Array} ratios current photon ratios (R, G, B)\n * @property {Float32Array} prefs preferred photon ratios\n * @property {Float32Array} floatVals direct access to float value array (for debug)\n * @return {Mote}\n */\nfunction Mote() {\n\tvar _photons = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array(3);\n\n\tvar pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Float32Array(2);\n\tvar pool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\tvar bSpeed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _photonomix.MOTE_BASE_SPEED;\n\tvar bSight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _photonomix.MOTE_BASE_SIGHT;\n\tvar bAgro = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1.0;\n\tvar bFear = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1.0;\n\n\tvar buffer = void 0,\n\t    offset = 0 | 0;\n\tif (pool) {\n\t\tbuffer = pool.buffer;\n\t\toffset = pool.allocate();\n\t} else {\n\t\tbuffer = new ArrayBuffer(BUFFER_LENGTH);\n\t\toffset = 0;\n\t}\n\n\t// \"private\" properties\n\t// use a single buffer for properties so that they're guaranteed to be contiguous\n\t// in memory and typed\n\tvar photons = new Uint8ClampedArray(buffer, U8_PHO + offset, 3);\n\tvar color = new Uint8ClampedArray(buffer, U8_COL + offset, 3);\n\tphotons[_Photon.COLOR_R] = _photons[_Photon.COLOR_R];\n\tphotons[_Photon.COLOR_G] = _photons[_Photon.COLOR_G];\n\tphotons[_Photon.COLOR_B] = _photons[_Photon.COLOR_B];\n\tvar intVals = new Int8Array(buffer, I8_BYTE_OFFSET + offset, I8_VAL_LENGTH - U8_PHO);\n\tvar floatVals = new Float32Array(buffer, F32_BYTE_OFFSET + offset, FLOAT_VAL_LENGTH);\n\tthis.pos = vec2(pos, buffer, F32_POS * F32 + VEC_BYTE_OFFSET + offset);\n\tthis.vel = vec2(0.0, 0.0, buffer, F32_VEL * F32 + VEC_BYTE_OFFSET + offset);\n\tvar ratios = new Float32Array(buffer, F32_RAT * F32 + VEC_BYTE_OFFSET + offset, 3);\n\tvar prefs = new Float32Array(buffer, F32_PREF * F32 + VEC_BYTE_OFFSET + offset, 3);\n\tthis.target = undefined;\n\tthis.color_string = \"\";\n\tbSpeed = bSpeed + (0, _photonomix2.adjRand)(0.0005);\n\tbSight = bSight + (0, _photonomix2.adjRand)(0.001); // vision distance\n\tbAgro = bAgro + (0, _photonomix2.adjRand)(0.001);\n\tbFear = bFear + (0, _photonomix2.adjRand)(0.001);\n\n\tObject.defineProperties(this, {\n\t\t\"photons\": { get: function get() {\n\t\t\t\treturn photons;\n\t\t\t} },\n\t\t\"color\": { get: function get() {\n\t\t\t\treturn color;\n\t\t\t} },\n\t\t\"dying\": { get: function get() {\n\t\t\t\treturn intVals[I8_DYING];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_DYING] = v;\n\t\t\t} },\n\t\t\"action\": { get: function get() {\n\t\t\t\treturn intVals[I8_ACT];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_ACT] = v;\n\t\t\t} },\n\t\t\"pregnant\": { get: function get() {\n\t\t\t\treturn intVals[I8_PREG];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_PREG] = v;\n\t\t\t} },\n\t\t\"injured\": { get: function get() {\n\t\t\t\treturn intVals[I8_INJURED];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_INJURED] = v;\n\t\t\t} },\n\t\t\"lastInjury\": { get: function get() {\n\t\t\t\treturn intVals[I8_LAST_INJURY];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_LAST_INJURY] = v;\n\t\t\t} },\n\t\t\"needsUpdate\": { get: function get() {\n\t\t\t\treturn intVals[I8_UPD];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_UPD] = v;\n\t\t\t} },\n\t\t\"pulse\": { get: function get() {\n\t\t\t\treturn intVals[I8_PULSE];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_PULSE] = v;\n\t\t\t} },\n\t\t\"lastMeal\": { get: function get() {\n\t\t\t\treturn intVals[I8_MEAL];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn intVals[I8_MEAL] = v;\n\t\t\t} },\n\t\t\"size\": { get: function get() {\n\t\t\t\treturn floatVals[F32_SIZE];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_SIZE] = v;\n\t\t\t} },\n\t\t\"sizeMin\": { get: function get() {\n\t\t\t\treturn floatVals[F32_SIZE_MIN];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_SIZE_MIN] = v;\n\t\t\t} },\n\t\t\"sizeMax\": { get: function get() {\n\t\t\t\treturn floatVals[F32_SIZE_MAX];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_SIZE_MAX] = v;\n\t\t\t} },\n\t\t\"speed\": { get: function get() {\n\t\t\t\treturn floatVals[F32_SPEED];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_SPEED] = v;\n\t\t\t} },\n\t\t\"sight\": { get: function get() {\n\t\t\t\treturn floatVals[F32_SIGHT];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_SIGHT] = v;\n\t\t\t} },\n\t\t\"agro\": { get: function get() {\n\t\t\t\treturn floatVals[F32_AGRO];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_AGRO] = v;\n\t\t\t} },\n\t\t\"fear\": { get: function get() {\n\t\t\t\treturn floatVals[F32_FEAR];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_FEAR] = v;\n\t\t\t} },\n\t\t\"potential\": { get: function get() {\n\t\t\t\treturn floatVals[F32_POTENTIAL];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_POTENTIAL] = v;\n\t\t\t} },\n\t\t\"resistance\": { get: function get() {\n\t\t\t\treturn floatVals[F32_RESISTANCE];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_RESISTANCE] = v;\n\t\t\t} },\n\t\t\"mass\": { get: function get() {\n\t\t\t\treturn floatVals[F32_MASS];\n\t\t\t}, set: function set(v) {\n\t\t\t\treturn floatVals[F32_MASS] = v;\n\t\t\t} },\n\t\t\"base_speed\": { get: function get() {\n\t\t\t\treturn bSpeed;\n\t\t\t} },\n\t\t\"base_sight\": { get: function get() {\n\t\t\t\treturn bSight;\n\t\t\t} },\n\t\t\"base_agro\": { get: function get() {\n\t\t\t\treturn bAgro;\n\t\t\t} },\n\t\t\"base_fear\": { get: function get() {\n\t\t\t\treturn bFear;\n\t\t\t} },\n\t\t\"pool\": { get: function get() {\n\t\t\t\treturn pool;\n\t\t\t} },\n\t\t\"offset\": { get: function get() {\n\t\t\t\treturn offset;\n\t\t\t} },\n\t\t\"ratios\": { get: function get() {\n\t\t\t\treturn ratios;\n\t\t\t} },\n\t\t\"prefs\": { get: function get() {\n\t\t\t\treturn prefs;\n\t\t\t} }\n\t});\n\n\t/*\n  * Debug access only.\n  */\n\tif (_photonomix.DEBUG) Object.defineProperties(this, {\n\t\t\"intVals\": { get: function get() {\n\t\t\t\treturn intVals;\n\t\t\t} },\n\t\t\"floatVals\": { get: function get() {\n\t\t\t\treturn floatVals;\n\t\t\t} }\n\t});\n\n\t// initialize values, important to do since buffer may be reused\n\tthis.dying = 0;\n\tthis.pregnant = 0;\n\tthis.injured = 0;\n\tthis.lastInjury = 0;\n\tthis.speed = bSpeed;\n\tthis.sight = bSight;\n\tthis.agro = bAgro;\n\tthis.fear = bFear;\n\tthis.potential = this.agro * 2;\n\tthis.resistance = this.fear * 2;\n\tthis.lastMeal = ~~(random() * 3);\n\tthis.pulse = ~~(_photonomix.TARGET_FPS * random());\n\tthis.size = _photonomix.MOTE_BASE_SIZE;\n\tthis.sizeMin = _photonomix.MOTE_BASE_SIZE * 0.5;\n\tthis.sizeMax = _photonomix.MOTE_BASE_SIZE * 3;\n\n\tthis.updateProperties();\n\tthis.prefs[_Photon.COLOR_R] = this.ratios[_Photon.COLOR_R];\n\tthis.prefs[_Photon.COLOR_G] = this.ratios[_Photon.COLOR_G];\n\tthis.prefs[_Photon.COLOR_B] = this.ratios[_Photon.COLOR_B];\n\treturn this;\n}\n\n/**\n * Updates derived properties for mote.\n */\nMote.prototype.updateProperties = function () {\n\tvar r = 0 | 0,\n\t    g = 0 | 0,\n\t    b = 0 | 0,\n\t    photons = void 0,\n\t    color = void 0,\n\t    ratios = void 0;\n\treturn function updateProperties() {\n\t\tphotons = this.photons;\n\t\tratios = this.ratios;\n\t\tcolor = this.color;\n\n\t\tr = photons[_Photon.COLOR_R];\n\t\tg = photons[_Photon.COLOR_G];\n\t\tb = photons[_Photon.COLOR_B];\n\t\tthis.mass = r + g + b;\n\t\tif (this.mass > 0) {\n\t\t\t// otherwise skip this stuff since the mote is dead anyway\n\t\t\tthis.size = clamp(this.mass / (_photonomix.PREGNANT_THRESHOLD / 3) * _photonomix.MOTE_BASE_SIZE, this.sizeMin, this.sizeMax);\n\t\t\tratios[_Photon.COLOR_R] = (0, _photonomix2.ratio)(r, g + b);\n\t\t\tratios[_Photon.COLOR_G] = (0, _photonomix2.ratio)(g, r + b);\n\t\t\tratios[_Photon.COLOR_B] = (0, _photonomix2.ratio)(b, g + r);\n\t\t\tthis.speed = this.base_speed * (1 - this.size) * (1 + ratios[_Photon.COLOR_B]);\n\t\t\tthis.sight = this.base_sight + this.size * 0.5; // see from edge onward\n\t\t\tthis.agro = this.base_agro * (1 + ratios[_Photon.COLOR_R]);\n\t\t\tthis.fear = this.base_fear * (1 + ratios[_Photon.COLOR_G]);\n\t\t\tif (_photonomix.DEBUG) {\n\t\t\t\tif (isNaN(this.speed)) throw new Error(\"Mote.updateProperties: NaN speed\");\n\t\t\t\tif (isNaN(this.sight)) throw new Error(\"Mote.updateProperties: NaN sight\");\n\t\t\t\tif (isNaN(this.size)) throw new Error(\"Mote.updateProperties: NaN size\");\n\t\t\t\tif (isNaN(this.agro)) throw new Error(\"Mote.updateProperties: NaN agro\");\n\t\t\t\tif (isNaN(this.fear)) throw new Error(\"Mote.updateProperties: NaN fear\");\n\t\t\t}\n\t\t} // end of stuff to do only if sum > 0\n\n\t\tif (this.mass > _photonomix.PREGNANT_THRESHOLD && this.pregnant === 0) this.pregnant = _photonomix.PREGNANT_TIME;\n\t\tif (this.mass < _photonomix.DEATH_THRESHOLD && this.dying === 0) this.dying = 1;\n\n\t\tcolor[_Photon.COLOR_R] = ~~(r / this.mass * 255);\n\t\tcolor[_Photon.COLOR_G] = ~~(g / this.mass * 255);\n\t\tcolor[_Photon.COLOR_B] = ~~(b / this.mass * 255);\n\t\tthis.needsUpdate = 0;\n\t};\n}();\n\n/**\n * Maintenance tasks to be done each tick\n */\nMote.prototype.runMaintenance = function () {\n\tvar pregnant = 0 | 0,\n\t    dying = 0 | 0,\n\t    tmpPot = 0.0,\n\t    tmpRes = 0.0,\n\t    agro = 0.0,\n\t    fear = 0.0,\n\t    size = 0.0,\n\t    speed = 0.0,\n\t    sight = 0.0,\n\t    pos = void 0,\n\t    vel = void 0,\n\t    target = void 0;\n\treturn function runMaintenance(delta) {\n\t\tpos = this.pos;\n\t\tvel = this.vel;\n\t\tpregnant = this.pregnant;\n\t\tdying = this.dying;\n\t\tagro = this.agro;\n\t\tfear = this.fear;\n\t\tsize = this.size;\n\t\tspeed = this.speed;\n\t\tsight = this.sight;\n\t\ttarget = this.target;\n\n\t\tif (pregnant > 0) this.pregnant = pregnant - 1;\n\t\tif (dying > 0) this.dying = dying + 1; // start counting up\n\t\tif (this.needsUpdate) this.updateProperties();\n\t\t// build potential and resistance each tick\n\t\ttmpPot = agro * (size * 100);\n\t\ttmpRes = fear * (size * 100);\n\t\tthis.potential = clamp(this.potential + agro * delta, -tmpPot, tmpPot);\n\t\tthis.resistance = clamp(this.resistance + fear * delta, -tmpRes, tmpRes);\n\n\t\t// last turn's move, has to happen first to avoid prediction inaccuracy\n\t\t// during chases\n\t\tmut_plus(pos, times(vel, delta, scratch1));\n\n\t\t// don't go off the screen\n\t\tmut_plus(vel, (0, _photonomix2.avoid)(vel, pos, POS_C, 1.3, speed, scratch1));\n\t\t// apply drag\n\t\tmut_plus(vel, (0, _photonomix2.drag)(vel, _photonomix.GLOBAL_DRAG));\n\t};\n}();\n\n/**\n * Checks if a target is valid.\n * @param {Object} entity any game object that can be targeted\n * @return {float} distance if valid, otherwise -1\n */\nMote.prototype.validateTarget = function () {\n\tvar dist = 0.0,\n\t    sight = 0.0,\n\t    pos = void 0;\n\treturn function (entity) {\n\t\tpos = this.pos;\n\t\tsight = this.sight;\n\n\t\tdist = distance(pos, entity.pos);\n\t\t// these targets are invalid\n\t\tif (entity === this) return -1;\n\t\tif (entity.dying) return -1;\n\t\tif (entity.lifetime && entity.lifetime < 3) return -1;\n\t\tif (entity.mass < 1) return -1;\n\t\tif (dist > sight + entity.size * 0.5) return -1;\n\t\tif ((0, _photonomix2.outOfBounds)(entity, 0.7)) return -1;\n\t\treturn dist;\n\t};\n}();\n\n/**\n * Search for a target and decide how to act toward it.\n */\nMote.prototype.search = function () {\n\tvar i = 0 | 0,\n\t    len = 0 | 0,\n\t    sight = 0.0,\n\t    cur = 0.0,\n\t    pos = void 0,\n\t    vel = void 0,\n\t    highest = void 0,\n\t    dist = void 0,\n\t    entity = void 0,\n\t    deltar = 0.0,\n\t    deltag = 0.0,\n\t    deltab = 0.0,\n\t    mind = 0.0,\n\t    maxd = 0.0,\n\t    weight = 0.0;\n\treturn function search(entities) {\n\t\tpos = this.pos;\n\t\tvel = this.vel;\n\t\tsight = this.sight;\n\n\t\thighest = -Infinity;\n\t\tdist = 0;\n\t\tif (this.pregnant || this.dying) {\n\t\t\tthis.action = ACT_IDLE;\n\t\t\thighest = Infinity;\n\t\t}\n\n\t\tfor (i = 0, len = entities.length; i < len && highest < Infinity; ++i) {\n\t\t\tentity = entities[i];\n\t\t\tvar _dist = this.validateTarget(entity);\n\t\t\tif (_dist === -1) continue;\n\t\t\t// ignore things outside sight range\n\t\t\tif (entity instanceof Mote) {\n\t\t\t\tcur = 3 * (1 / _dist);\n\t\t\t\tif (cur > highest) {\n\t\t\t\t\tthis.target = entity;\n\t\t\t\t\tif (entity.target === this || _dist < (this.size + entity.size) * 0.5) {\n\t\t\t\t\t\tthis.action = ACT_AVOID;\n\t\t\t\t\t} else this.action = ACT_CHASE;\n\t\t\t\t\thighest = cur;\n\t\t\t\t}\n\t\t\t} else if (entity instanceof _Void2.default) {\n\t\t\t\tthis.target = entity;\n\t\t\t\tthis.action = ACT_AVOID;\n\t\t\t\thighest = Infinity;\n\t\t\t} else if (entity instanceof _Photon2.default && entity.lifetime > 3) {\n\t\t\t\tdeltar = this.prefs[_Photon.COLOR_R] - this.ratios[_Photon.COLOR_R];\n\t\t\t\tdeltag = this.prefs[_Photon.COLOR_G] - this.ratios[_Photon.COLOR_G];\n\t\t\t\tdeltab = this.prefs[_Photon.COLOR_B] - this.ratios[_Photon.COLOR_B];\n\t\t\t\tmaxd = max(deltar, deltag, deltab);\n\t\t\t\tmind = min(deltar, deltag, deltab);\n\t\t\t\tif (maxd == deltar && entity.color == _Photon.COLOR_R || maxd == deltag && entity.color == _Photon.COLOR_G || maxd == deltab && entity.color == _Photon.COLOR_B) weight = 30;\n\t\t\t\tif (mind == deltar && entity.color == _Photon.COLOR_R || mind == deltag && entity.color == _Photon.COLOR_G || mind == deltab && entity.color == _Photon.COLOR_B) weight = 10;else weight = 20;\n\t\t\t\tcur = weight * (1 / _dist);\n\t\t\t\tif (cur > highest) {\n\t\t\t\t\tthis.target = entity;\n\t\t\t\t\tthis.action = ACT_CHASE;\n\t\t\t\t\thighest = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (highest < 0) return false;\n\t\treturn true;\n\t};\n}();\n\n/**\n * Decide how to act each tick based on nearby objects.\n * @param Array surrounding array of nearby objects to consider in movement\n * @param Float delta time delta\n */\nMote.prototype.tick = function () {\n\tvar pos = void 0,\n\t    vel = void 0,\n\t    size = void 0,\n\t    sight = void 0,\n\t    speed = void 0,\n\t    agro = void 0,\n\t    fear = void 0,\n\t    resistance = void 0,\n\t    potential = void 0,\n\t    target = void 0,\n\t    dist = void 0;\n\treturn function tick(entities, delta, frameCount) {\n\t\tpos = this.pos;\n\t\tvel = this.vel;\n\t\tsize = this.size;\n\t\tsight = this.sight;\n\t\tspeed = this.speed;\n\t\tagro = this.agro;\n\t\tfear = this.fear;\n\t\tresistance = this.resistance;\n\t\tpotential = this.potential;\n\t\ttarget = this.target;\n\n\t\tthis.runMaintenance(delta);\n\n\t\t// validate current target \n\t\tif (target && (dist = this.validateTarget(target)) === -1) {\n\t\t\tthis.action = ACT_IDLE;\n\t\t}\n\n\t\tswitch (this.action) {\n\t\t\tcase ACT_IDLE:\n\t\t\t\t// lost target, gave up, or completed task\n\t\t\t\tthis.target = undefined;\n\t\t\t\tif (magnitude(vel) < 0.001) {\n\t\t\t\t\t// not going anywhere, so pick a random direction\n\t\t\t\t\tscratch1[0] = random() * 2 - 1;\n\t\t\t\t\tscratch1[1] = random() * 2 - 1;\n\t\t\t\t} else {\n\t\t\t\t\tmut_copy(scratch1, pos);\n\t\t\t\t\tmut_plus(scratch1, times(vel, delta, scratch2));\n\t\t\t\t\tmut_plus(scratch1, (0, _photonomix2.rotate)(scratch1, pos, sin((frameCount + this.pulse) * speed), scratch2));\n\t\t\t\t}\n\t\t\t\tmut_plus(vel, (0, _photonomix2.accelerate)(pos, scratch1, speed, scratch2));\n\t\t\t\tthis.action = ACT_SEARCH;\n\t\t\t\tbreak;\n\t\t\tcase ACT_CHASE:\n\t\t\t\t// chasing a target\n\t\t\t\t// predict target's next move\n\t\t\t\tplus(target.pos, times(target.vel, delta, scratch1), scratch2);\n\t\t\t\tmut_plus(vel, (0, _photonomix2.accelerate)(pos, scratch2, speed, scratch1));\n\t\t\t\tif (dist < sight) {\n\t\t\t\t\tif (target instanceof Mote && this.potential > this.agro * 3) this.action = ACT_ATTACK;else this.action = ACT_ATTACK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ACT_AVOID:\n\t\t\t\t// avoiding a target\n\t\t\t\t// predict target's next move\n\t\t\t\tplus(target.pos, times(target.vel, delta, scratch1), scratch2);\n\t\t\t\tmut_plus(vel, (0, _photonomix2.accelerate)(scratch2, pos, speed, scratch1));\n\t\t\t\tif (this.resistance > fear * 3) this.action = ACT_IDLE;\n\t\t\t\tbreak;\n\t\t\tcase ACT_ATTACK:\n\t\t\t\t// attacking a target\n\t\t\t\tif (target instanceof Mote) this.discharge(target);else if (target instanceof _Photon2.default) this.eatPhoton(target);\n\t\t\t\tbreak;\n\t\t\tcase ACT_LINK:\n\t\t\t\t// linking with a target\n\t\t\t\tbreak;\n\t\t\tcase ACT_SEARCH:\n\t\t\t\tif (!this.search(entities)) this.action = ACT_IDLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n}();\n\nvar delta = 0.0;\nMote.prototype.discharge = function (target) {\n\tdelta = this.potential - target.resistance;\n\ttarget.resistance -= max(this.agro, delta * this.agro);\n\tthis.potential -= max(this.fear, delta * this.fear);\n\ttarget.injure(this, max(0, ~~delta));\n\tif (this.potential < 0) this.action = ACT_IDLE;\n};\n\nMote.prototype.injure = function (by, strength) {\n\tthis.injured += strength;\n\tthis.lastInjury = this.injured;\n\tif (this.resistance < this.agro * 3 || this.injured < this.fear) this.target = by;\n};\n\nMote.prototype.bleed = function () {\n\tvar choice = 0 | 0,\n\t    choiceVal = 0 | 0,\n\t    pvel = vec2(),\n\t    photons = void 0;\n\treturn function bleed(photonPool) {\n\t\tphotons = this.photons;\n\t\tdo {\n\t\t\tchoice = ~~(random() * 3);\n\t\t\tswitch (choice) {\n\t\t\t\tcase _Photon.COLOR_R:\n\t\t\t\t\tchoiceVal = photons[_Photon.COLOR_R];break;\n\t\t\t\tcase _Photon.COLOR_G:\n\t\t\t\t\tchoiceVal = photons[_Photon.COLOR_G];break;\n\t\t\t\tcase _Photon.COLOR_B:\n\t\t\t\t\tchoiceVal = photons[_Photon.COLOR_B];break;\n\t\t\t}\n\t\t} while (choiceVal === 0);\n\t\tswitch (choice) {\n\t\t\tcase _Photon.COLOR_R:\n\t\t\t\tphotons[_Photon.COLOR_R] = photons[_Photon.COLOR_R] - 1;break;\n\t\t\tcase _Photon.COLOR_G:\n\t\t\t\tphotons[_Photon.COLOR_G] = photons[_Photon.COLOR_G] - 1;break;\n\t\t\tcase _Photon.COLOR_B:\n\t\t\t\tphotons[_Photon.COLOR_B] = photons[_Photon.COLOR_B] - 1;break;\n\t\t}\n\t\tthis.injured--;\n\t\tmut_times(this.vel, 1 + this.speed);\n\t\tmut_copy(pvel, this.vel);\n\t\tmut_times(pvel, -1);\n\t\tthis.needsUpdate = 1;\n\t\treturn new _Photon2.default(this.pos, pvel, choice, photonPool);\n\t\t//return choice;\n\t};\n}();\n\nMote.prototype.split = function () {\n\tvar baby = void 0,\n\t    photons = void 0;\n\treturn function () {\n\t\tphotons = this.photons;\n\t\tbaby = new Mote([floor(photons[_Photon.COLOR_R] / 2), floor(photons[_Photon.COLOR_G] / 2), floor(photons[_Photon.COLOR_B] / 2)], this.pos, this.pool, this.base_speed, this.base_sight, this.base_agro, this.base_fear);\n\t\tphotons[_Photon.COLOR_R] = ceil(photons[_Photon.COLOR_R] / 2);\n\t\tphotons[_Photon.COLOR_G] = ceil(photons[_Photon.COLOR_G] / 2);\n\t\tphotons[_Photon.COLOR_B] = ceil(photons[_Photon.COLOR_B] / 2);\n\t\tthis.pregnant = _photonomix.PREGNANT_TIME - 1;\n\t\tbaby.pregnant = _photonomix.PREGNANT_TIME - 1;\n\t\tthis.target = baby;\n\t\tbaby.target = this;\n\t\tbaby.needsUpdate = 1;\n\t\tthis.needsUpdate = 1;\n\t\treturn baby;\n\t};\n}();\n\nMote.prototype.eatPhoton = function () {\n\tvar photons = void 0;\n\treturn function eatPhotons(photon) {\n\t\tif (photon.lifetime > 2 && distance(this.pos, photon.pos) < this.sight) {\n\t\t\tphotons = this.photons;\n\t\t\tphoton.lifetime = 2;\n\t\t\tswitch (photon.color) {\n\t\t\t\tcase _Photon.COLOR_R:\n\t\t\t\t\tphotons[_Photon.COLOR_R] += 1;break;\n\t\t\t\tcase _Photon.COLOR_G:\n\t\t\t\t\tphotons[_Photon.COLOR_G] += 1;break;\n\t\t\t\tcase _Photon.COLOR_B:\n\t\t\t\t\tphotons[_Photon.COLOR_B] += 1;break;\n\t\t\t}\n\t\t\tthis.lastMeal = photon.color;\n\t\t\tthis.potential -= this.agro * 0.5;\n\t\t\tthis.resistance -= this.fear * 0.5;\n\t\t\tthis.needsUpdate = 1;\n\t\t}\n\t\tthis.action = ACT_IDLE;\n\t};\n}();\n\nvar rpos = new Float32Array(2);\nvar rphotons = new Uint8ClampedArray(3);\n/**\n * Generates mote with randomized position and photon values.\n * @param {BufferPool} pool storage pool\n * @return {Mote}\n */\nMote.random = function (pool) {\n\tdo {\n\t\trpos[0] = random() * (0, _photonomix2.posneg)();\n\t\trpos[1] = random() * (0, _photonomix2.posneg)();\n\t} while (magnitude(rpos) > 0.8);\n\trphotons[0] = ~~(random() * 64);\n\trphotons[1] = ~~(random() * 64);\n\trphotons[2] = ~~(random() * 64);\n\treturn new Mote(rphotons, rpos, pool);\n};\n\nMote.prototype.destroy = function () {\n\tthis.pool.free(this.offset);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/game/Mote.js\n// module id = 17\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = Void;\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomix = require(\"../photonomix.util\");\n\nvar _ = require(\"./\");\n\nvar _photonomix2 = require(\"../photonomix.constants\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    times = _vectrix$vectors.times,\n    mut_times = _vectrix$vectors.mut_times,\n    distance = _vectrix$vectors.distance;\nvar mut_plus = vectrix.matrices.mut_plus;\nvar random = Math.random,\n    sqrt = Math.sqrt,\n    PI = Math.PI,\n    ceil = Math.ceil,\n    min = Math.min;\n\nvar POS_C = vec2(0, 0);\n\nfunction Void() {\n\tvar ipos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : vec2();\n\tvar ivel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vec2();\n\tvar mass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n\tthis.pos = vec2(ipos);\n\tthis.vel = vec2(ivel);\n\tthis.size = 0;\n\tthis.birthMass = mass;\n\tthis.mass = 1;\n\tthis.lastMeal = -1;\n\tthis.eatTime = 0;\n\treturn this;\n}\n\nvar scratchVec1 = vec2(),\n    entity = void 0,\n    i = 0 | 0,\n    len = 0 | 0,\n    a_dist = 0.0,\n    consume = 0 | 0;\nVoid.prototype.tick = function (entities, delta) {\n\tif (this.birthMass > 0) {\n\t\tconsume = min(this.birthMass, ceil(this.mass / 100));\n\t\tthis.birthMass -= consume;\n\t\tthis.mass += consume;\n\t}\n\tif (this.eatTime > 30) this.eatTime--;else this.lastMeal = -1;\n\tif ((0, _photonomix.outOfBounds)(this.pos, 1.3)) {\n\t\tthis.mass = this.mass - 1;\n\t}\n\tthis.size = sqrt(this.mass / PI) * _photonomix2.VOID_SIZE;\n\t// last turn's move, has to happen first\n\tmut_plus(this.pos, times(this.vel, delta, scratchVec1));\n\n\t// apply basic forces\n\t// don't go off the screen\n\tmut_plus(this.vel, (0, _photonomix.avoid)(this.vel, this.pos, POS_C, 1.3, 0.01, scratchVec1));\n\t// apply drag\n\tmut_plus(this.vel, (0, _photonomix.drag)(this.vel, _photonomix2.GLOBAL_DRAG));\n\t(0, _photonomix.limitVecMut)(this.vel, 0, 1);\n\n\tfor (i = 0, len = entities.length; i < len; ++i) {\n\t\tentity = entities[i];\n\t\tif (entity === this) continue;\n\t\ta_dist = distance(this.pos, entity.pos);\n\n\t\tif (entity instanceof _.Photon && a_dist < this.size) {\n\t\t\tentity.lifetime = entity.lifetime - 1;\n\t\t\tif (entity.lifetime === 0 || a_dist < this.size * 0.6) {\n\t\t\t\tthis.mass = this.mass + 1;\n\t\t\t\tthis.lastMeal = entity.color;\n\t\t\t\tthis.eatTime = 15;\n\t\t\t\tentity.lifetime = 0;\n\t\t\t}\n\t\t}\n\t\tif (entity instanceof _.Mote && a_dist < this.size * 0.6) {\n\t\t\t// probablistic injury, so they don't get shredded instantly\n\t\t\tif (random() * 30 * a_dist < 1) entity.injured = entity.injured + 1;\n\t\t}\n\t\tif (entity instanceof Void) {\n\t\t\tif (a_dist < (entity.size + this.size) * 0.44) {\n\t\t\t\t// bigger ones eat smaller ones\n\t\t\t\tif (this.mass > entity.mass) {\n\t\t\t\t\tconsume = min(entity.mass, ceil(this.birthMass + this.mass / 100));\n\t\t\t\t\tthis.birthMass += consume;\n\t\t\t\t\tentity.mass -= consume;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!entity.mass) continue; // zero mass means gravity bugs\n\t\t// apply gravity\n\t\tif (entity instanceof _.Emitter) {\n\t\t\t// emitters have negative & repelling mass\n\t\t\tmut_plus(entity.vel, mut_times((0, _photonomix.gravitate)(entity.pos, this.pos, this.mass / entity.mass, scratchVec1), 1 / entity.mass));\n\t\t} else if (!(entity instanceof _.AntiGravitonCluster)) {\n\t\t\tmut_plus(entity.vel, mut_times((0, _photonomix.gravitate)(entity.pos, this.pos, entity.mass * this.mass, scratchVec1), 1 / entity.mass));\n\t\t}\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/game/Void.js\n// module id = 18\n// module chunks = 0","import * as controls from \"./src/controls\";\nimport * as graphics from \"./src/graphics\";\nimport * as display from \"./src/pxene.display\";\nimport * as events from \"./src/pxene.events\";\nimport * as util from \"./src/pxene.util\";\nimport * as assets from \"./src/pxene.assets\";\nimport BooleanArray from \"./src/pxene.BooleanArray\";\nimport ObjectPool from \"./src/pxene.ObjectPool\";\nimport CollisionMap from \"./src/pxene.CollisionMap\";\n\nexport {display, controls, events, util, assets, graphics, ObjectPool, BooleanArray, CollisionMap};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/index.js\n// module id = 19\n// module chunks = 0","\"use strict\";\n/**\n * @module pxene.controls.KeyMap\n * contains the KeyMap prototype.\n */\n\n/**\n * Data type for handling mappings of keys to control labels.\n * @example\n * ```javascript\n * let jump = pxene.controls.map(\"jump\", \"space\");\n * jump.down(); // true or false depending on whether the spacebar is down\n * pxene.controls.map(\"jump\", \"esc\");\n * jump.isDown(); // true if either space or esc are down \n * jump.lastDown(); // most recent time either space or esc were pressed down\n * jump.LastUp(); // most recent time either space or esc were released\n * jump.unmap(\"esc\"); // now jump only pays attention to spacebar\n *\n * // The controls module keeps track of your control mappings, so you don't\n * // have to worry about losing them. Once you've created the \"jump\" label\n * // above you can always look it up later:\n * let jump = pxene.controls.lookupMap(\"jump\");\n * ```\n * @param {String} label the label for the mapping\n * @return KeyMap object\n */\nexport default function KeyMap(label) {\n\tlabel = label.toLowerCase();\n\tthis.label = label;\n\tthis.keys = [];\n\tthis.checkedDown = 0;\n\tthis.checkedUp = 0;\n\treturn Object.seal(this);\n}\n\nKeyMap.prototype.lastDown = function lastDown() {\n\treturn this.keys.reduce((p, c) => p = (p > c.lastDown?p:c.lastDown), 0);\n}\n\nKeyMap.prototype.lastUp = function lastUp() {\n\treturn this.keys.reduce((p, c) => p = (p > c.lastDown?p:c.lastDown), 0);\n}\n\nKeyMap.prototype.isDown = function isDown() {\n\treturn this.keys.reduce((p, c) => p = p || c.down, false);\n}\n\nKeyMap.prototype.onceDown = function onceDown() {\n\tif(this.lastUp() >= this.checkedDown && this.isDown()) {\n\t\tthis.checkedDown = Date.now();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nKeyMap.prototype.onceUp = function onceUp() {\n\tif(this.lastDown() >= this.checkedUp && !this.isDown()) {\n\t\tthis.checkedUp = Date.now();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/controls/KeyMap.js\n// module id = 20\n// module chunks = 0","\"use strict\";\n/**\n * @module pxene.controls.KeyState\n * contains the KeyState prototype.\n */\n\n/**\n * Data type for tracking the state of a single key.\n * @param {string} key key name, as defined in [KeyboardEvent.key]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values}\n * @return {KeyState}\n */\nexport default function KeyState(key) {\n\tthis.key = key;\n\tthis.down = false;\n\tthis.lastDown = 0;\n\tthis.lastUp = 0;\n\treturn Object.seal(this);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/controls/KeyState.js\n// module id = 21\n// module chunks = 0","\"use strict\";\n/**\n * @module pxene.graphics.Atlas\n *\n * Contains the Atlas prototype.\n */\nimport * as assets from \"../pxene.assets\";\nimport {vectors} from \"@nphyx/vectrix\";\n\n/** a cache of already processed Atlases **/\nconst cache = [];\n/**\n * Much like a sprite, an atlas is a collection of smaller images on a single sheet.\n * An atlas may have non-uniform cell sizes, and is more suitable for static graphics.\n *\n * @todo Implement me\n */\nexport default function Atlas(layers, animations, slices) {\n\tthis.layers = layers;\n\tthis.animations = animations;\n\tthis.slices = slices;\n\tthis.source = undefined;\n\tthis.context = undefined;\n\tthis.flippedContext = undefined;\n\tthis.ready = false;\n\treturn Object.seal(this);\n}\n\n/**\n * Initializes the sprite with an image, copying it to the sprite's internal\n * canvas.\n * @param {Image} image a loaded Image element\n * @param {bool} flipped whether to generate a horizontally flipped version (default: true)\n */\nAtlas.prototype.init = function init(image, flipped = true) {\n\tthis.source = image;\n\tlet canvas = document.createElement(\"canvas\");\n\tcanvas.width = image.width;\n\tcanvas.height = image.height;\n\tlet context = canvas.getContext(\"2d\");\n\tcontext.drawImage(image, 0, 0);\n\tthis.context = context;\n\tif(flipped) this.generateFlipped();\n\tthis.ready = true;\n}\n\n/**\n * Generates a horizontally flipped version of the sprite with all the cells\n * at the same indexes. Normally run during {@link init} but can be called\n * manually if init was instructed not to create the flipped version.\n */\nAtlas.prototype.generateFlipped = function generateFlipped() {\n\tlet canvas = document.createElement(\"canvas\");\n\tcanvas.width = this.context.canvas.width;\n\tcanvas.height = this.context.canvas.height;\n\tlet context = canvas.getContext(\"2d\");\n\tcontext.scale(-1, 1);\n\tlet i, len, layer;\n\t// let's not create functions within loops\n\tlet eachSlice = (key) => {\n\t\tlet slice = this.slices[key];\t\n\t\tlet source = vectors.vec2(slice.pos);\n\t\tvectors.mut_plus(source, layer.frames[i].pos);\n\t\tcontext.drawImage(\n\t\t\tthis.context.canvas,\n\t\t\tsource[0], source[1],\n\t\t\tslice.dims[0], slice.dims[1],\n\t\t\t-source[0]-slice.dims[0], source[1],\n\t\t\tslice.dims[0], slice.dims[1]\n\t\t);\n\n\t}\n\n\tlet eachLayer = (key) => {\n\t\tlayer = this.layers[key];\n\t\tfor(i = 0, len = layer.frames.length; i < len; ++i) {\n\t\t\tObject.keys(this.slices).filter(key => key !== \"default\").forEach(eachSlice);\n\t\t}\n\t}\n\n\tObject.keys(this.layers).forEach(eachLayer); \n\n\tcontext.setTransform(1, 0, 0, 1, 0, 0);\n\tthis.flippedContext = context;\n}\n\n/**\n * Draw a slice from the atlas to the given context.\n * @param {CanvasContext2d} dest the destination context\n * @param {string} name the name of the slice to draw\n * @param {vec2} pos the top left corner to start drawing at\n * @param {bool} flipped horizontal flip toggle (to reverse facing of image)\n * @param {Array} layers list of layers by name to draw\n */\nAtlas.prototype.draw = function(dest, label, pos, flipped = false, layers = undefined) {\n\tlet slice = (\n\t\t\tthis.slices[label]?\n\t\t\tthis.slices[label]:\n\t\t\tthis.slices.default);\n\tlet canvas = flipped?this.flippedContext.canvas:this.context.canvas;\n\n\t// draw all layers if a layer list isn't specified\n\tif(layers === undefined) layers = Object.keys(this.layers);\n\tlayers.forEach(layer => {\n\t\tlet source = vectors.vec2(slice.pos);\n\t\t//vectors.mut_plus(source, this.layers[layer].pos);\n\t\tvectors.mut_plus(source, this.layers[layer].frames[0].pos);\n\t\tdest.drawImage(\n\t\t\tcanvas,\n\t\t\tsource[0], source[1],\n\t\t\tslice.dims[0], slice.dims[1],\n\t\t\tpos[0], pos[1],\n\t\t\tslice.dims[0], slice.dims[1]\n\t\t);\n\t});\n}\n\n/**\n * Draws a sprite frame from a given animation set, or the default animation\n * if the specified animation is incorrect.\n * @param {CanvasRenderingContext2D} dest the destination context\n * @param {string} label the name of the animation to draw\n * @param {vec2} pos the top left corner from which to start drawing\n * @param {int} frame the frame number to draw\n * @param {bool} flip horizontal flip toggle (to reverse facing of sprite)\n * @param {Array} layers list of layers by name to draw\n */\nAtlas.prototype.animate = function animate(dest, label, pos, frame, flipped = false, layers = undefined) {\n\t// draw all layers if a layer list isn't specified\n\tif(layers === undefined) layers = Object.keys(this.layers);\n\n\tlet animation = (\n\t\t\tthis.animations[label]?\n\t\t\tthis.animations[label]:\n\t\t\tthis.animations.default);\n\n\tlet frameNum = animation.start + (frame % animation.length);\n\tlet canvas = flipped?this.flippedContext.canvas:this.context.canvas; \n\tlayers.forEach(layer => {\n\t\tlet frame = this.layers[layer].frames[frameNum];\n\t\tdest.drawImage(\n\t\t\tcanvas,\n\t\t\tframe.pos[0], frame.pos[1],\n\t\t\tframe.dims[0], frame.dims[1],\n\t\t\tpos[0], pos[1], \n\t\t\tframe.dims[0], frame.dims[1])\n\t});\n}\n\n/**\n * Creates a new Atlas by combining into a single layer the listed layers, \n * in the order supplied.\n * @param {Array} layers list of layers by label\n * @return {Atlas}\n *\n * @todo implement me\n */\nAtlas.prototype.prebake = function prebake() {\n\tthrow new Error(\"unimplemented\");\n}\n\n/**\n * Create a new Atlas from an imported AsepriteAtlas. Returns a promise\n * which resolves with an atlas once it's ready to use. Accepts a callback for\n * processing the data property on layers and slices, which defaults to treating\n * it as a string.\n *\n * @todo a gulp module that exports with the correct options to make this work\n *\n * @param {string} uri a URI for an atlas JSON file\n * @param {function} dataCallback custom function for transforming the \"data\" parameter\n * @return {Promise}\n */\nAtlas.fromAsepriteAtlas = function fromAsepriteAtlas(uri, dataCallback) {\n\tdataCallback = dataCallback || function(a) {return a};\n\t/**\n\t * uniq used below to filter unique tags, due to aseprite bug\n\t * which creates duplicate entries\n\t */\n\t//const uniq = (v, i, self) => self.indexOf(v) === i;\n\treturn new Promise((resolve) => {\n\t\tif(cache[uri] !== undefined && cache[uri] instanceof Atlas) {\n\t\t\tresolve(cache[uri]);\n\t\t}\n\t\telse {\n\t\t\tconsole.log(assets);\n\t\t\tassets.requestAsset(uri).then((asset) => {\n\t\t\t\tlet aspr = asset.content;\n\t\t\t\tlet width = aspr.meta.size.w;\n\t\t\t\tlet height = aspr.meta.size.h;\n\t\t\t\tlet numLayers = aspr.meta.layers.length;\n\t\t\t\tlet numFrames = aspr.frames.length / numLayers;\n\t\t\t\tlet layerHeight = height / numLayers;\n\n\t\t\t\t// Hash of layers by name to be added to the Atlas\n\t\t\t\tlet layers = {}, layer;\n\t\t\t\tlet layerNames = [];\n\n\t\t\t\taspr.meta.layers.forEach((l, i) => {\n\t\t\t\t\tlayerNames.push(l.name);\n\t\t\t\t\tif(layers[l.name] === undefined) {\n\t\t\t\t\t\tlayer = {\n\t\t\t\t\t\t\tlabel:l.name.trim(),\n\t\t\t\t\t\t\tdata:dataCallback(l.data?l.data:\"\"),\n\t\t\t\t\t\t\topacity:l.opacity,\n\t\t\t\t\t\t\tblendMode:l.blendMode,\n\t\t\t\t\t\t\tpos:vectors.vec2(0, i * layerHeight),\n\t\t\t\t\t\t\tframes:[]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlayers[layer.label] = Object.freeze(layer);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Hash of animations by name to be added to the Atlas\n\t\t\t\tlet slices = {\n\t\t\t\t\tdefault:{\n\t\t\t\t\t\tlabel:\"default\",\n\t\t\t\t\t\tdata:dataCallback(\"\"),\n\t\t\t\t\t\tpos:vectors.vec2(0, 0),\n\t\t\t\t\t\tdims:vectors.vec2(width, height)\n\t\t\t\t\t}\n\t\t\t\t}, slice;\n\n\t\t\t\taspr.meta.slices.forEach(s => {\n\t\t\t\t\t// as of v1.2.2, aseprite duplicates frame tags once per\n\t\t\t\t\t// layer but the data is always the same\n\t\t\t\t\tif(slices[s.name] === undefined) {\n\t\t\t\t\t\tslice = {\n\t\t\t\t\t\t\tlabel:s.name.trim(),\n\t\t\t\t\t\t\tdata:dataCallback(s.data?s.data:\"\"),\n\t\t\t\t\t\t\tpos:vectors.vec2(s.keys[0].bounds.x, s.keys[0].bounds.y),\n\t\t\t\t\t\t\tdims:vectors.vec2(s.keys[0].bounds.w, s.keys[0].bounds.h)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tslices[slice.label] = Object.freeze(slice);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Hash of animations by name to be added to the Atlas\n\t\t\t\tlet animations = {}, animation;\n\n\t\t\t\taspr.meta.frameTags.forEach(f => {\n\t\t\t\t\t// as of v1.2.2, aseprite duplicates frame tags once per\n\t\t\t\t\t// layer but the data is always the same\n\t\t\t\t\tif(animations[f.name] === undefined) {\n\t\t\t\t\t\t animation = {\n\t\t\t\t\t\t\tlabel:f.name.trim(),\n\t\t\t\t\t\t\tstart:f.from,\n\t\t\t\t\t\t\tlength:(f.to - f.from) + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanimations[animation.label] = Object.freeze(animation);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\taspr.frames.forEach((f, i) => {\n\t\t\t\t\tlet layer = layers[layerNames[~~(i / numFrames)]];\n\t\t\t\t\tlet frame = {\n\t\t\t\t\t\t//label:f.name.trim(),\n\t\t\t\t\t\tpos:vectors.vec2(f.frame.x, f.frame.y),\n\t\t\t\t\t\tdims:vectors.vec2(f.frame.w, f.frame.h)\n\t\t\t\t\t}\n\t\t\t\t\tlayer.frames.push(Object.freeze(frame));\n\t\t\t\t});\n\n\t\t\t\tassets.requestAsset(aspr.meta.image).then((image) => {\n\t\t\t\t\tlet atlas = new Atlas(\n\t\t\t\t\t\tObject.seal(layers),\n\t\t\t\t\t\tObject.seal(animations),\n\t\t\t\t\t\tObject.seal(slices)\n\t\t\t\t\t);\n\t\t\t\t\tatlas.init(image.content);\n\t\t\t\t\tcache[uri] = atlas;\n\t\t\t\t\tresolve(atlas);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/graphics/Atlas.js\n// module id = 22\n// module chunks = 0","\"use strict\";\n/**\n * @module pxene.graphics.BitmapFont\n *\n * Contains the BitmapFont prototype.\n */\n\n/**\n * A bitmap font is a fixed-size font contained in a single bitmap image, \n * similar to a Sprite or Atlas. The BitmapFont object manages loading the font\n * and writing text to a canvas using the font.\n * @todo implement me\n */\nexport default function BitmapFont() {\n\treturn this;\n}\n\n/**\n * Initializes the font with an image.\n * @param {Image} image a loaded Image element\n */\nBitmapFont.prototype.init = function(image) {\n}\n\n/**\n * Draws text to canvas.\n * @param {string} text text contents to write\n * @param {CanvasContext2d} target canvas context to write to\n * @param {int} sx start x-coordinate\n * @param {int} sy start y-coordinate\n * @param {int} wl wrap length in pixels\n * @param {int} lh space between lines in pixels (optional, default 1)\n * @param {int}\tls letter spacing in pixels (optional, default 1) \n */\nBitmapFont.prototype.write = function(text, target, sx, sy, lw, ls = 1) {\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/graphics/BitmapFont.js\n// module id = 23\n// module chunks = 0","\"use strict\";\n/**\n * @module pxene.graphics.CompositeSprite\n *\n * Contains the CompositeSprite prototype.\n */\nexport default function CompositeSprite() {\n\treturn this;\n}\n\n/**\n * Generates a composite sprite from the image list the sprite was loaded with.\n */\nCompositeSprite.prototype.init = function init(sprites) {\n\tlet canvas = document.createElement(\"canvas\");\n\tcanvas.width = this.width = sprites[0].width;\n\tcanvas.height = this.height = sprites[0].height;\n\tthis.columns = canvas.width / this.frameWidth;\n\tthis.rows = canvas.height / this.frameHeight;\n\tlet context = canvas.getContext(\"2d\");\n\tfor(let i = 0, len = sprites.length; i < len; ++i) {\n\t\tcontext.drawImage(sprites[i], 0, 0);\n\t}\n\tthis.ready = true;\n\tthis.spriteCanvas = canvas;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/graphics/CompositeSprite.js\n// module id = 24\n// module chunks = 0","\"use strict\";\nimport * as assets from \"../pxene.assets\";\n/**\n * @module pxene.graphics.Sprite\n *\n * Contains the Sprite prototype, as well as the internally managed sprite cache.\n */\n/** a cache of already processed Sprites **/\nlet cache = [];\n\n/**\n * An image subdivided into individual cells suitable for character animations. The\n * Sprite object manages data related to the location of individual animations, and\n * drawing of individual cells to an external canvas.\n */\nexport default function Sprite(frameCount, frameWidth, frameHeight, animations) {\n\tthis.frameCount = frameCount;\n\tthis.frameWidth = frameWidth;\n\tthis.frameHeight = frameHeight;\n\tthis.animations = animations;\n\tthis.context = undefined;\n\tthis.flippedContext = undefined;\n\tthis.ready = false;\n\t// below calculated during generateComposite\n\tthis.width = 0; \n\tthis.height = 0;\n\tthis.rows = 0;\n\tthis.columns = 0;\n\treturn Object.seal(this);\n}\n\n/**\n * Initializes the sprite with an image, copying it to the sprite's internal\n * canvas.\n * @param {Image} image a loaded Image element\n * @param {bool} flipped whether to generate a horizontally flipped version (default: true)\n */\nSprite.prototype.init = function init(image, flipped = true) {\n\tlet canvas = document.createElement(\"canvas\");\n\tcanvas.width = this.width = image.width;\n\tcanvas.height = this.height = image.height;\n\tthis.columns = canvas.width / this.frameWidth;\n\tthis.rows = canvas.height / this.frameHeight;\n\tlet context = canvas.getContext(\"2d\");\n\tcontext.drawImage(image, 0, 0);\n\tthis.context = context;\n\tif(flipped) this.generateFlipped();\n\tthis.ready = true;\n}\n\n\n/**\n * Generates a horizontally flipped version of the sprite with all the cells\n * at the same indexes. Normally run during {@link init} but can be called\n * manually if init was instructed not to create the flipped version.\n */\nSprite.prototype.generateFlipped = function generateFlipped() {\n\tlet canvas = document.createElement(\"canvas\");\n\tcanvas.width = this.width;\n\tcanvas.height = this.height;\n\tlet context = canvas.getContext(\"2d\");\n\tlet row, col, sx, sy, dx, dy;\n\tlet rows = this.rows;\n\tlet cols = this.cols;\n\tlet w = this.frameWidth;\n\tlet h = this.frameHeight;\n\n\tcontext.scale(-1, 1);\n\tfor(row = 0, rows = this.rows; row < rows; ++row) {\n\t\tfor(col = 0, cols = this.columns; col < cols; ++col) {\n\t\t\tsx = col * w;\n\t\t\tdx = sx; //((cols - col) * w) - w;\n\t\t\tsy = dy = row * h;\n\t\t\tcontext.drawImage(this.context.canvas, sx, sy, w, h, -sx-w, dy, w, h);\n\t\t}\n\t}\n\tcontext.setTransform(1, 0, 0, 1, 0, 0);\n\tthis.flippedContext = context;\n}\n\n/**\n * Draws a sprite frame from a given animation set, or the default animation\n * if the specified animation is incorrect.\n * @param {CanvasRenderingContext2D} dest the destination context\n * @param {string} name the name of the animation to draw\n * @param {int} frame the frame number to draw\n * @param {vec2} pos the top left corner from which to start drawing\n * @param {bool} flip horizontal flip toggle (to reverse facing of sprite)\n */\nSprite.prototype.draw = function draw(dest, name, frame, pos, flipped = false) {\n\tlet animation = (\n\t\t\tthis.animations[name]?\n\t\t\tthis.animations[name]:\n\t\t\tthis.animations.default);\n\tlet frameNum = animation.startFrame + (frame % animation.length);\n\tlet {frameWidth, frameHeight} = this;\n\tlet canvas = flipped?this.flippedContext.canvas:this.context.canvas; \n\tdest.drawImage(\n\t\tcanvas,\n\t\tgetX(this, frameNum), getY(this, frameNum),\n\t\tframeWidth, frameHeight,\n\t\tpos[0], pos[1], \n\t\tframeWidth, frameHeight);\n}\n\n/**\n * Figures out the x offset for a frame based on the frame number and the sprite's parameters.\n */\nfunction getX(sprite, frameNum) {\n\treturn (frameNum % sprite.columns) * sprite.frameWidth;\n}\n\n/**\n * Figures out the x offset for a frame based on the frame number and the sprite's parameters.\n */\nfunction getY(sprite, frameNum) {\n\treturn Math.floor(frameNum / sprite.columns) * sprite.frameHeight;\n}\n\n/**\n * Create a new Sprite from an imported AsepriteAtlas. Returns a promise\n * which resolves with a sprite once it's ready to use.\n *\n * @param {string} uri a URI for an atlas JSON file\n * @return {Promise}\n */\nSprite.fromAsepriteAtlas = function fromAsepriteAtlas(uri) {\n\treturn new Promise((resolve) => {\n\t\tif(cache[uri] !== undefined && cache[uri] instanceof Sprite) {\n\t\t\tresolve(cache[uri]);\n\t\t}\n\t\telse {\n\t\t\tconsole.log(assets);\n\t\t\tassets.requestAsset(uri).then((asset) => {\n\t\t\t\tlet aspr = asset.content;\n\t\t\t\tlet animations = {\n\t\t\t\t\tdefault:{\n\t\t\t\t\tlabel:\"default\",\n\t\t\t\t\tstartFrame:0,\n\t\t\t\t\tlength:1\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(aspr.meta.frameTags) aspr.meta.frameTags.forEach((anim) => {\n\t\t\t\t\tanimations[anim.name.toLowerCase()] = {\n\t\t\t\t\t\tlabel:anim.name.toLowerCase(),\n\t\t\t\t\t\tstartFrame:anim.from,\n\t\t\t\t\t\tlength:(anim.to - anim.from) + 1\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tassets.requestAsset(aspr.meta.image).then((image) => {\n\t\t\t\t\tlet sprite = new Sprite(\n\t\t\t\t\t\taspr.frames.length,\n\t\t\t\t\t\taspr.frames[0].frame.w,\n\t\t\t\t\t\taspr.frames[0].frame.h,\n\t\t\t\t\t\tanimations\n\t\t\t\t\t);\n\t\t\t\t\tsprite.init(image.content);\n\t\t\t\t\tcache[uri] = sprite;\n\t\t\t\t\tresolve(sprite);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/graphics/Sprite.js\n// module id = 25\n// module chunks = 0","\"use strict\";\n/**\n * @module pxene.graphics\n *\n * Handles import, initialization and use of various specialized graphics\n * resources.\n */\nimport Sprite from \"./Sprite\";\nimport CompositeSprite from \"./CompositeSprite\";\nimport Atlas from \"./Atlas\";\nimport BitmapFont from \"./BitmapFont\";\n\nexport {Sprite, CompositeSprite, Atlas, BitmapFont};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/graphics/index.js\n// module id = 26\n// module chunks = 0","\"use strict\";\n/**\n * @module pxene.BooleanArray\n */\n\n/**\n * A BooleanArray is a TypedArray-like implementation for integer-indexed\n * boolean fields. It lets you store a set of boolean values in an arraybuffer,\n * which allows for better potential memory use in circumstances where you need\n * to set more than 2 booleans on a single data set\\*, and potentially slightly\n * better performance (though probably not significantly).\n *\n * It's probably not incredibly useful in most circumstances, but when you have\n * an object with a bunch of boolean flags and you're going to make a bunch of\n * that kind of object it might come in handy.\n *\n * In short, if you don't know whether you need this you almost certainly don't.\n *\n * *_most sources indicate a boolean occupies 4 bytes of javascript memory due \n * to storage and indexing overhead. In contrast, a BooleanArray can store up \n * to 8 booleans in around the same amount of memory (and the proportionate \n * savings grow the more booleans you have to store, since an arraybuffer\n * has a small fixed overhead)._\n */\nconst internalArray = Symbol();\n\nexport default function BooleanArray() {\n\tif((arguments[0] instanceof ArrayBuffer) && (typeof arguments[1] === \"number\") && (typeof arguments[2] === \"number\")) {\n\t\t\tthis[internalArray] = new Uint8Array(arguments[0], arguments[1], Math.ceil(arguments[2]/8));\n\t}\n\telse if(typeof arguments[0] === \"number\") {\n\t\tthis[internalArray] = new Uint8Array(Math.ceil(arguments[0]/8));\n\t}\n\telse throw Error(\"expected either length or buffer, offset, length as arguments\");\n\tthis.length = this[internalArray].byteLength * 8;\n\tObject.freeze(this);\n\treturn this;\n}\n\n/**\n * Gets a boolean by index.\n */\nBooleanArray.prototype.get = function get(n) {\n\tlet i = ~~(n/8);\n\tlet s = n % 8;\n\treturn (this[internalArray][i] & (1 << s))?true:false;\n}\n\n/**\n * Sets an index to the truthiness of the given value.\n * @param {int} n index to set\n * @param {truthy|falsy} v value to set\n */\nBooleanArray.prototype.set = function set(n, v) {\n\tlet i = ~~(n/8);\n\tlet s = n % 8;\n\tif(v) { // any kind of truthy is ok!\n\t\tthis[internalArray][i] |= 1 << s;\n\t}\n\telse {\n\t\tthis[internalArray][i] &= 255 ^ (1 << s);\n\t}\n}\n\n/**\n * Fill the array with a value.\n * @param {truthy|falsy} v\n */\nBooleanArray.prototype.fill = function(v) {\n\tthis[internalArray].fill(v?255:0);\n}\n\n/**\n * For useful compatibility with {@link pxene.ObjectPool}.\n */\nBooleanArray.prototype.recycle = function() {\n\tthis[internalArray].fill(0);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.BooleanArray.js\n// module id = 27\n// module chunks = 0","\"use strict\";\n//import BooleanArray from \"./pxene.BooleanArray\";\nconst {floor} = Math;\n/** mask a full rectangle **/\nconst MASK_16 = Math.pow(2, 16) - 1;\n/** used to generate offset masks **/\nconst MASK_X = new Uint16Array(4);\n/** used to generate offset masks **/\nconst MASK_Y = new Uint16Array(4);\n/** mask offsets from the top **/\nconst MASK_TOP = new Uint16Array(4);\n/** mask offsets from the bottom **/\nconst MASK_BOTTOM = new Uint16Array(4);\n/** mask offsets from the right **/\nconst MASK_RIGHT = new Uint16Array(4);\n/** mask offsets from the left **/\nconst MASK_LEFT = new Uint16Array(4);\n\n/**\n * Precompute a bunch of useful masks for fast shape checks. Done this way\n * to illustrate/keep track of how they're constructed instead of just using\n * \"magic numbers\".\n */\nMASK_X[0] = 1 | (1 << 4) | (1 << 8) | (1 << 12);\nMASK_X[1] = MASK_X[0] << 1;\nMASK_X[2] = MASK_X[0] << 2;\nMASK_X[3] = MASK_X[0] << 3;\nif((MASK_X[0] | MASK_X[1] | MASK_X[2] | MASK_X[3]) !== MASK_16) throw new Error(\"MASK_X is bad\");\n\nMASK_Y[0] = (1 << 4) - 1; \nMASK_Y[1] = MASK_Y[0] << 4;\nMASK_Y[2] = MASK_Y[0] << 8;\nMASK_Y[3] = MASK_Y[0] << 12;\nif((MASK_Y[0] | MASK_Y[1] | MASK_Y[2] | MASK_Y[3]) !== MASK_16) throw new Error(\"MASK_Y is bad\");\n\nMASK_TOP[0] = 0;\nMASK_TOP[1] = MASK_Y[3];\nMASK_TOP[2] = MASK_TOP[1] | MASK_Y[2];\nMASK_TOP[3] = MASK_TOP[2] | MASK_Y[1];\n\nMASK_BOTTOM[0] = 0;\nMASK_BOTTOM[1] = MASK_Y[0];\nMASK_BOTTOM[2] = MASK_BOTTOM[1] | MASK_Y[1];\nMASK_BOTTOM[3] = MASK_BOTTOM[2] | MASK_Y[2];\n\nMASK_RIGHT[0] = 0;\nMASK_RIGHT[1] = MASK_X[3];\nMASK_RIGHT[2] = MASK_RIGHT[1] | MASK_X[2];\nMASK_RIGHT[3] = MASK_RIGHT[2] | MASK_X[1];\n\nMASK_LEFT[0] = 0;\nMASK_LEFT[1] = MASK_X[0];\nMASK_LEFT[2] = MASK_LEFT[1] | MASK_X[1];\nMASK_LEFT[3] = MASK_LEFT[2] | MASK_X[2];\n\n\n/**\n * @module pxene.CollisionMap\n *\n * Module containing {@link CollisionMap} prototype.\n */\n\nconst internal_array = Symbol();\n\n/**\n * @constructor\n * A collision map is a 2d grid of boolean true/false values, meant to be\n * used for collision testing.\n *\n * @param {int} width the width of the grid\n * @param {int} height the height of the grid\n * @return {CollisionMap}\n */\nexport default function CollisionMap(width = 0, height = 0) {\n\tthis.width = 0;\n\tthis.height = 0;\n\tthis.cellWidth = 0;\n\tthis.cellHeight = 0;\n\tthis.length = 0;\n\tif(width && height) this.init(width, height);\n\treturn this;\n}\n\n/* helpful(?) constants */\n/** pixel array index offset for the red channel **/\nCollisionMap.CHANNEL_RED = 0;\n/** pixel array index offset for the green channel **/\nCollisionMap.CHANNEL_GREEN = 1;\n/** pixel array index offset for the blue channel **/\nCollisionMap.CHANNEL_BLUE = 2;\n/** pixel array index offset for the alpha channel **/\nCollisionMap.CHANNEL_ALPHA = 3;\n\n/**\n * Creates a per-pixel collision map from a Canvas.\n * @param {Canvas} canvas the canvas to read pixel data from\n * @param {int} threshold the threshold above which a pixel will be considered solid (default 0) \n * @param {int} channel the channel to check against (default {@link CollisionMap.CHANNEL_ALPHA}) \n * @return {CollisionMap} \n *\n * @note internal canvas pixel data stores alpha in a range of 0 to 255, so\n * convert from [0 - 1] to [0 - 255] if providing a threshold \n */\nCollisionMap.fromCanvasPixels = function(canvas, threshold = 0, channel = CollisionMap.CHANNEL_ALPHA) {\n\tconsole.time(\"new CollisionMap\");\n\tlet map = new CollisionMap(canvas.width, canvas.height);\n\tconsole.timeEnd(\"new CollisionMap\");\n\tlet pixels;\n\tlet context = canvas.getContext(\"2d\");\n\tconsole.time(\"fromCanvasPixels loop\");\n\tlet once = true;\n\tfor(let y = 0, h = canvas.height; y < h; y += 100) {\n\t\t// go 100 rows at time with the image data for sanity/memory use\n\t\ttry {\n\t\t\tif(once) console.time(\"getImageData\");\n\t\t\tpixels = context.getImageData(0, y, canvas.width, 100).data;\n\t\t\tif(once) console.timeEnd(\"getImageData\");\n\t\t}\n\t\tcatch(e) {\n\t\t\tthrow new Error(\"CollisionData:failed to get image data :(\");\n\t\t}\n\t\tif(once) console.time(\"loop map.set\");\n\t\tfor(let i = 0, len = pixels.length; i < len; i+=4) {\n\t\t\tlet mx = (i / 4) % canvas.width, my = y + (~~((i / 4) / canvas.width));\n\t\t\tif(pixels[i+channel] > threshold) map.set(mx, my, true);\n\t\t}\n\t\tif(once) console.timeEnd(\"loop map.set\");\n\t\tonce = false;\n\t}\n\tconsole.timeEnd(\"fromCanvasPixels loop\");\n\treturn map;\n}\n\n/**\n * Returns the bit for the given set of coordinates.\n */\nconst cellBit = CollisionMap.cellBit = function cellBit(x, y) {\n\treturn 1 << ((x % 4) + ((y % 4)*4));\n}\n\n/**\n * Returns the mask which excludes the given bit coordinate from the cell.\n */\nconst cellMask = CollisionMap.cellMask = function cellMask(x, y) {\n\treturn invertMask(cellBit(x, y));\n}\n\nconst cellIndex = CollisionMap.cellIndex = function cellIndex(x, y, w) {\n\treturn (floor(y/4) * floor(w/4)) + floor(x/4) \n}\n\n\n/**\n * Reinitializes the map with a new width and height.\n * @param {int} width\n * @param {int} height\n * @return {self}\n */\nCollisionMap.prototype.init = function(width, height) {\n\tthis.width = ~~width;\n\tif(this.width % 4) this.width += (4 - (~~width % 4)); // round to nearest 4\n\tthis.height = ~~height;\n\tif(this.height % 4) this.height += (4 - (~~height % 4)); // round to nearest 4\n\tthis.cellWidth = this.width / 4;\n\tthis.cellHeight = this.height / 4;\n\tlet newlen = (this.cellWidth * this.cellHeight);\n\tif(this.length !== newlen) {\n\t\tthis.length = newlen;\n\t\tif(this.length) {\n\t\t\tthis[internal_array] = new Uint16Array(this.length);\n\t\t}\n\t}\n\telse if(this[internal_array]) this[internal_array].fill(0);\n\treturn this;\n}\n\nCollisionMap.prototype.getCell = function getCell(x, y) {\n\treturn this[internal_array][cellIndex(x, y, this.width)];\n}\n\nCollisionMap.prototype.get = function get(x, y) {\n\treturn (this.getCell(x, y) & cellBit(x, y))?1:0;\n}\n\nCollisionMap.prototype.set = function set(x, y, v) {\n\tif(v) this[internal_array][cellIndex(x, y, this.width)] |= cellBit(x, y);\n\telse this[internal_array][cellIndex(x, y, this.width)] &= cellMask(x, y);\n}\n\n/**\n * Checks a rectangular area of the CollisionMap, returning a count of solid\n * grid sections within.\n *\n * @param {int} x start x coordinate\n * @param {int} y start y coordinate\n * @param {int} w width of rectangle\n * @param {int} h height of rectangle \n * @return {int}\n */\nCollisionMap.prototype.checkRect = function checkRect(x, y, w, h) {\n\tlet offsetX = x % 4;\n\tlet offsetY = y % 4;\n\tlet cellWidth = Math.ceil((offsetX + w) / 4);\n\tlet cellHeight = Math.ceil((offsetY + h) / 4);\n\tlet maskX, maskY;\n\tfor(let cellY = 0; cellY < cellHeight; ++cellY) {\n\t\tif(cellY === 0) maskY = MASK_TOP[offsetY];\n\t\telse if(cellY === (cellHeight - 1)) maskY = MASK_BOTTOM[offsetY];\n\t\telse maskY = MASK_16;\n\t\tfor(let cellX = 0; cellX < cellWidth; ++cellX) {\n\t\t\tif(cellX === 0) maskX = MASK_LEFT[offsetX];\n\t\t\telse if(cellX === (cellWidth - 1)) maskX = MASK_RIGHT[offsetX];\n\t\t\telse maskX = MASK_16;\n\t\t\tif(maskX & maskY & this[internal_array][(cellY * this.cellWidth) + cellX]) return 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Intersects two CollisionMaps, returning a sum of the count of overlapping\n * solid areas.\n * @param {CollisionMap} target the map to intersect with\n * @param {int} sx start x of this map\n * @param {int} sy start y of this map\n * @param {int} tx start x of the target map\n * @param {int} ty start y of the target map\n * @param {int} w width of area to collide\n * @param {int} h height of area to collide\n * @return {int}\n * @todo examine whether fast intersection by blocks of 8 sectors is doable\n */\nCollisionMap.prototype.intersect = function intersect(target, sx, sy, tx, ty, w, h) {\n\tlet x, y, sum = 0;\n\tfor(y = 0; y < h; ++y) {\n\t\tfor(x = 0; x < h; ++x) {\n\t\t\tsum += (this.get(sx+x, sy+y) && target.get(tx+x, ty+y))?1:0;\t\n\t\t}\n\t}\n\treturn sum;\n}\n\nfunction invertMask(mask) {\n\treturn MASK_16 ^ mask;\n}\n\n// export constants for debugging\nCollisionMap.MASK_X = MASK_X;\nCollisionMap.MASK_Y = MASK_Y;\nCollisionMap.MASK_TOP = MASK_TOP;\nCollisionMap.MASK_BOTTOM = MASK_BOTTOM;\nCollisionMap.MASK_LEFT = MASK_LEFT;\nCollisionMap.MASK_RIGHT = MASK_RIGHT;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.CollisionMap.js\n// module id = 28\n// module chunks = 0","\"use strict\";\n/**\n * @module ObjectPool\n * Simple auto-expanding object pool.\n */\n\n/**\n * A simple object pool, which expands itself automatically when needed but\n * prefers to recycle objects when available.  *\n * The factory function passed as a parameter should generate uniform objects, \n * even though the factory pattern suggests a factory can produce made-to-purpose \n * objects. The point of accepting a factory rather than a constructor is only to \n * support programming styles that prefer not to use constructors or classes.\n *\n * Objects created by the pool will be [sealed]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal}\n * to enforce the uniformity requirement externally.\n *\n * Objects in the pool may support a recyle() method, which cleans up an object\n * and readies it for reuse, as well as an init() function, which allows pass-\n * through support for {@link ObjectPool.prototype.allocate()} parameters.\n *\n * @param {function} factory a function that returns one pool object\n */\n\nexport default function ObjectPool(factory) {\n\tconst pool = [];\n\tconst freed = [];\n\tvar open = true;\n\n\t/**\n\t * Allocate an item from the pool (either recycled or new as available).\n\t * Parameters are passed through to the init() method of the pool object\n\t * if it has one.\n\t * @throws Error if the pool is closed and there are no free objects\n\t */\n\tthis.allocate = function allocate(...args) {\n\t\tlet obj;\n\t\tif(freed.length) obj = freed.pop();\n\t\telse if(open) {\n\t\t\tobj = Object.seal(factory());\n\t\t\tpool.push(obj);\n\t\t}\n\t\telse throw new Error(\"pool is closed\");\n\t\tif(typeof(obj.init) === \"function\") obj.init.apply(obj, args);\n\t\treturn obj;\n\t}\n\n\t/**\n\t * Free an object for reuse. If the object has a recycle() method, it will\n\t * be called during this operation.\n\t */\n\tthis.free = function free(obj) {\n\t\tif(pool.indexOf(obj) > -1) {\n\t\t\tif(typeof(obj.recycle) === \"function\") obj.recycle();\n\t\t\tfreed.push(obj);\n\t\t}\n\t\telse throw new Error(\"free called with non-pool-member\");\n\t}\n\n\t/**\n\t * Pre-allocate a bunch of objects if you want to have some available\n\t * ahead of time.\n\t */\n\tthis.preAllocate = function(n) {\n\t\tif(!open) throw new Error(\"pool is closed\");\n\t\tlet obj;\n\t\tfor(let i = 0; i < n; ++i) {\n\t\t\tobj = factory();\n\t\t\tpool.push(obj);\n\t\t\tfreed.push(obj);\n\t\t}\n\t}\n\n\t/**\n\t * Closes the pool, so that no new objects will be created.\n\t */\n\tthis.close = function() {\n\t\topen = false;\n\t}\n\n\t/**\n\t * Opens the pool if closed.\n\t */\n\tthis.open = function() {\n\t\topen = true;\n\t}\n\n\tObject.defineProperties(this, {\n\t\tlength:{get:() => pool.length},\n\t\tavailable:{get:() => freed.length},\n\t\tused:{get:() => pool.length - freed.length}\n\t});\n\n\treturn Object.freeze(this);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.ObjectPool.js\n// module id = 29\n// module chunks = 0","/**\n * @module pxene.assets.mimeTypes\n * Manages the collection of mime type handlers used by the {@link pxene.assets} module to process\n * fetched assets.\n */\nconst mimeHandlers = {\n\t\"default\":(response) => new Promise(resolve => response.blob().then(blob => resolve(blob)))\n};\n\n/**\n * Adds a specialized handler for a given mime type. Can be used as a plugin system or to handle\n * specialized asset types. See {@link mimeTimeHandler} for information about the callback.\n *\n * @Example\n * ```javascript\n * addMimeHandler(\"some-type/subtype\", fn(originalUrl, response, resolve) {\n*   res.text().then(text => resolve(text, originalUrl, type));\n * });\n * @param {string} mimeType\n * @param {mimeTypeHandler} cb callback\n */\nexport function addHandler(mimeType, cb) {\n\tif(mimeHandlers[mimeType] === undefined) mimeHandlers[mimeType] = cb;\n\telse throw new Error(\"tried to add a mimeType but there's already a handler for it\");\n}\n\n/**\n * Looks up a mime type handler, returning the default handler if none is found.\n */\nexport function getHandler(mimeType) {\n\tif(typeof mimeHandlers[mimeType] === \"function\") return mimeHandlers[mimeType];\n\telse return mimeHandlers.default;\n}\n\n/**\n * A mime type handler callback function. This is a sort of middleware that does some preprocessing\n * on certain asset types before passing them on to the storage system.\n * @callback mimeTypeHandler\n * @param {Response} the Response object returned from a fetch()\n * @return {Promise} which resolves() with the final form of the asset to be stored\n */\n\n/**\n * A mime handler for image types.\n */\nfunction mimeTypeHandlerImages(response) {\n\treturn new Promise((resolve) => {\n\t\tresponse.blob().then((blob) => {\n\t\t\tlet img = document.createElement(\"img\");\n\t\t\timg.addEventListener(\"load\", () => resolve(img));\n\t\t\timg.src = URL.createObjectURL(blob);\n\t\t});\n\t});\n}\n\n/**\n * A mime type handler for plain text.\n */\nfunction mimeTypeHandlerText(response) {\n\treturn new Promise((resolve) => response.text().then(text => resolve(text)));\n}\n\n/**\n * A mime type handler for json objects.\n */\nfunction mimeTypeHandlerJSON(response) {\n\treturn new Promise((resolve) => response.json().then(json => resolve(json)));\n}\n\naddHandler(\"image/jpeg\", mimeTypeHandlerImages);\naddHandler(\"image/gif\",  mimeTypeHandlerImages);\naddHandler(\"image/png\",  mimeTypeHandlerImages);\naddHandler(\"text/html\", mimeTypeHandlerText);\naddHandler(\"text/plain\", mimeTypeHandlerText);\naddHandler(\"application/json\", mimeTypeHandlerJSON);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.assets.mimeTypes.js\n// module id = 30\n// module chunks = 0","\"use strict\";\n/**\n * An offscreen draw buffer, which will be drawn to a composite buffer for display\n * onscreen.\n * @param {string} compositeMethod globalCompositeMethod to use when compositing\n * @param {bool} scaleMethod method for scaling (see SCALE_* constants)\n * @param {string} context [2d|webGL]\n * @return {DrawBuffer}\n */\nconst {min} = Math;\nexport const SCALE_STRETCH = 0;\nexport const SCALE_KEEP_ASPECT = 1;\nexport const SCALE_NONE = 2;\nexport const SCALE_CROP = 3;\nexport function DrawBuffer(compositeMethod = \"source-over\", scaleMethod = SCALE_STRETCH, context = \"2d\") {\n\tthis.canvas = document.createElement(\"canvas\");\n\tthis.context = this.canvas.getContext(context);\n\tthis.offsetX = 0;\n\tthis.offsetY = 0;\n\tthis.compositeMethod = compositeMethod;\n\tthis.scaleMethod = scaleMethod;\n\tObject.defineProperties(this, {\n\t\twidth:{get:() => this.canvas.width, set:(v) => this.canvas.width = v},\n\t\theight:{get:() => this.canvas.height, set:(v) => this.canvas.height = v},\n\t});\n\treturn this;\n}\n\n/**\n * A canvas to draw a BufferGroup into.\n * @param {HTMLElement} container the containing element for the canvas\n * @return {CompositeBuffer}\n */\nexport function CompositeBuffer(container) {\n\tthis.canvas = document.createElement(\"canvas\");\n\tthis.context = this.canvas.getContext(\"2d\");\n\tthis.container = container;\n\tthis.container.appendChild(this.canvas);\n\tObject.defineProperties(this, {\n\t\twidth:{get:() => this.canvas.width, set:(v) => this.canvas.width = v},\n\t\theight:{get:() => this.canvas.height, set:(v) => this.canvas.height = v},\n\t});\n\treturn this;\n}\n\nexport const composite = (function() {\n\tlet i, len, sourceBuffer, targetContext;\n\tlet sw, sh, sx, sy, dw, dh, dx, dy;\n\treturn function composite(sourceBuffers, targetBuffer, displayProps) {\n\t\ttargetContext = targetBuffer.context;\n\t\t// if using a pixel ratio, assume it's for pixel art and don't screw it up\n\t\tif(displayProps.pixelRatio !== 1) targetContext.imageSmoothingEnabled = false;\n\t\tfor(i = 0, len = sourceBuffers.length; i < len; ++i) {\n\t\t\tsourceBuffer = sourceBuffers[i];\n\t\t\tif(targetContext.globalCompositeOperation !== sourceBuffer.compositeMethod)\n\t\t\t\ttargetContext.globalCompositeOperation = sourceBuffer.compositeMethod;\n\t\t\tswitch(sourceBuffer.scaleMethod) {\n\t\t\t\tcase SCALE_STRETCH:\n\t\t\t\t\tsx = 0; sy = 0; sw = sourceBuffer.width; sh = sourceBuffer.height;\n\t\t\t\t\tdx = sourceBuffer.offsetX; dy = sourceBuffer.offsetY; \n\t\t\t\t\tdw = targetBuffer.width; dh = targetBuffer.height;\n\t\t\t\tbreak;\n\t\t\t\tcase SCALE_KEEP_ASPECT:\n\t\t\t\t\tsx = 0; sy = 0; sw = sourceBuffer.width; sh = sourceBuffer.height;\n\t\t\t\t\tdx = sourceBuffer.offsetX; dy = sourceBuffer.offsetY; \n\t\t\t\t\tdw = targetBuffer.width; dh = targetBuffer.height;\n\t\t\t\t\tif(displayProps.orientation) {\n\t\t\t\t\t\tsw = targetBuffer.width;\n\t\t\t\t\t\tsh = min(targetBuffer.height, sourceBuffer.height);\n\t\t\t\t\t\tdw = min(targetBuffer.width, sourceBuffer.width);\n\t\t\t\t\t\tdh = targetBuffer.height;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsw = min(targetBuffer.width, sourceBuffer.width);\n\t\t\t\t\t\tsh = targetBuffer.height;\n\t\t\t\t\t\tdw = targetBuffer.width;\n\t\t\t\t\t\tdh = min(targetBuffer.height, sourceBuffer.height);\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase SCALE_CROP:\n\t\t\t\t\tsx = 0; sy = 0; \n\t\t\t\t\tsw = min(targetBuffer.width - sourceBuffer.offsetX, sourceBuffer.width);\n\t\t\t\t\tsh = min(targetBuffer.height - sourceBuffer.offsetY, sourceBuffer.height);\n\t\t\t\t\tdx = sourceBuffer.offsetX; dy = sourceBuffer.offsetY; \n\t\t\t\t\tdw = min(targetBuffer.width - sourceBuffer.offsetX, sourceBuffer.width);\n\t\t\t\t\tdh = min(targetBuffer.height - sourceBuffer.offsetY, sourceBuffer.height);\n\t\t\t\tbreak;\n\t\t\t\tdefault: // SCALE_NONE\n\t\t\t\t\tsx = 0; sy = 0; sw = sourceBuffer.width; sh = sourceBuffer.height;\n\t\t\t\t\tdx = sourceBuffer.offsetX; dy = sourceBuffer.offsetY; \n\t\t\t\t\tdw = sourceBuffer.width*displayProps.pixelRatio; dh = sourceBuffer.height*displayProps.pixelRatio;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttargetContext.drawImage(sourceBuffer.canvas, sx, sy, sw, sh, dx, dy, dw, dh); \n\t\t}\n\t}\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.display.buffers.js\n// module id = 31\n// module chunks = 0","\"use strict\";\nimport {drawCircle} from \"./pxene.display\";\nimport {DEBUG} from \"./pxene.constants\";\nimport * as controls from \"./controls\";\nconst {max} = Math;\n\nlet ctx, uiBuffer;\nlet displayProps;\n\n/**\n * Creates debug markers on screen to show the center, top, left, bottom, right, topleft\n * and topright extremes of the main game area.\n */\nconst debugMarkers = (function() {\n\tlet w, h, wh, hh;\n\treturn function debugMarkers() {\n\t\tw = displayProps.width;\n\t\th = displayProps.height;\n\t\twh = w/2; \n\t\thh = h/2;\n\t\tdrawCircle(ctx,  0,  0, 4, \"yellow\", 1, \"white\");\n\t\tdrawCircle(ctx, wh,  0, 4, \"orange\", 1, \"white\");\n\t\tdrawCircle(ctx,  w,  0, 4, \"red\", 1, \"white\");\n\t\tdrawCircle(ctx,  0, hh, 4, \"white\", 1, \"white\");\n\t\tdrawCircle(ctx, wh, hh, 4, \"gray\", 1, \"white\");\n\t\tdrawCircle(ctx,  w, hh, 4, \"black\", 1, \"white\");\n\t\tdrawCircle(ctx,  0,  h, 4, \"blue\", 1, \"white\");\n\t\tdrawCircle(ctx, wh,  h, 4, \"cyan\", 1, \"white\");\n\t\tdrawCircle(ctx,  w,  h, 4, \"green\", 1, \"white\");\n\t}\n})();\n\n/**\n * Draws an edge button.\n */\nfunction drawEdgeButton(ctx, x, y, w, h) {\n\tlet halfButtonWidth = w*0.5;\n\tlet buttonHeight = h;\n\tlet cpXScale = w*0.122;\n\tlet beginX = x-halfButtonWidth;\n\tlet beginY = y;\n\tlet topX = x;\n\tlet topY = y-buttonHeight;\n\tlet endX = x+halfButtonWidth;\n\tlet endY = y;\n\tlet aCPX = beginX + cpXScale;\n\tlet aCPY = beginY - cpXScale;\n\tlet bCPX = beginX + cpXScale;\n\tlet bCPY = topY;\n\tlet cCPX = endX - cpXScale;\n\tlet cCPY = topY;\n\tlet dCPX = endX - cpXScale;\n\tlet dCPY = endY - cpXScale;\n\tlet color = \"rgba(255,255,255,0.1)\";\n\n\tctx.beginPath();\n\tctx.moveTo(beginX, beginY);\n\tctx.bezierCurveTo(aCPX, aCPY, bCPX, bCPY, topX, topY);\n\tctx.bezierCurveTo(cCPX, cCPY, dCPX, dCPY, endX, endY);\n\tctx.fillStyle = color;\n\tctx.strokeStyle = color;\n\tctx.lineWidth = 4;\n\tctx.fill();\n\tctx.closePath();\n}\n\n/**\n * Draws UI elements.\n */\nexport function draw() {\n\tlet w = displayProps.width;\n\tlet h = displayProps.height;\n\tlet bw = max(100, w*0.1);\n\tlet bh = max(47,  w*0.047);\n\tlet {move, down} = controls.pointer;\n\tctx.clearRect(0, 0, w, h);\n\tdrawEdgeButton(ctx, w*0.5, h, bw, bh);\n\tdrawEdgeButton(ctx, w*0.333, h, bw, bh); \n\tdrawEdgeButton(ctx, w*0.666, h, bw, bh);  \n\tdrawCircle(ctx, move[0], move[1], 5, \"white\");\n\tif(controls.buttons[0]) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(down[0], down[1]);\n\t\tctx.lineTo(move[0], move[1]);\n\t\tctx.strokeStyle = \"white\";\n\t\tctx.lineWidth = 2;\n\t\tctx.stroke();\n\t\tctx.closePath();\n\t}\n\tif(DEBUG) debugMarkers();\n}\n\n/**\n * Initializes the UI submodule.\n * @param {DrawBuffer} buffer\n */\nexport function init(buffer, props) {\n\tdisplayProps = props;\n\tuiBuffer = buffer;\n\tupdateProps();\n\tdisplayProps.events.on(\"resize\", updateProps);\n\tctx = uiBuffer.context;\n}\n\nfunction updateProps() {\n\tuiBuffer.width = displayProps.width;\n\tuiBuffer.height = displayProps.height;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.display.ui.js\n// module id = 32\n// module chunks = 0","\"use strict\";\n\n\n/**\n * Draws a colored circle.\n */\nexport function drawCircle(ctx, x, y, size, fillStyle, lineWidth = 0, strokeStyle = undefined) {\n\tctx.globalCompositeOperation = \"source-over\";\n\tctx.beginPath();\n\tctx.arc(x, y, size, 2 * Math.PI, false);\n\tctx.fillStyle = fillStyle;\n\tctx.fill();\n\tif(strokeStyle) {\n\t\tctx.strokeStyle = strokeStyle;\n\t\tctx.lineWidth = lineWidth;\n\t\tctx.stroke();\n\t}\n\tctx.closePath();\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-pxene/src/pxene.display.util.js\n// module id = 33\n// module chunks = 0","\"use strict\";\n/**\nThe quaternions module focuses on quaternion operations that are useful for performing 3-dimensional rotations. Quaternions inherit from [[vectrix.vectors#vec4|4d-vectors]], which in turn inherit from [[vectrix.matrices|matrices]], so most of the operations supported by vec4 and generic matrices are supported by quats (TODO: remove the ones that don't make sense for quaternions)\n\nNote that in the examples quaternions outputs are displayed as they would be by quaternion.toString(), which rounds to the nearest 2 decimal points for brevity. Actual values will be accurate to at least 1.0e-7 (the minimum accuracy required by the unit tests).\n\nVectrix quaternions store their scalar component in the last place, so all quaternion functions that accept an array as a parameter expect it as [x,y,z,w] rather than [w,x,y,z]. This for consistency with the vectors module.\n\n```javascript\nconst quaternions = require(\"vectrix.quaternions\");\nlet q = quaternion.create([0.4, 1.0, 2.1, 1.0]); // quaternion(0.40, 1.00, 2.10, 1.0);\n```\nQuaternion values are aliased to x, y, z, and w, and can be accessed in any combination\nas with GLSL:\n```javascript\nq.xy; // [0.4, 1.0]\nq.zyx; // [2.1, 1.0, 0.4]\nq.zw; // [2.1, 1.0]\n// etc\n```\n@module vectrix/quaternions\n*/\n\nimport * as vectors from \"./vectrix.vectors\";\nimport * as matrices from \"./vectrix.matrices\";\nconst vecNrm = vectors.normalize;\nconst {abs, sin, cos, acos, sqrt} = Math;\n\n/**\n * @private\n */\nlet aliasCombos = [];\n\t\n[\"xyzw\", \"xyz\", \"xzw\", \"xyw\", \"yzw\", \"xy\", \"xw\", \"xz\", \"yz\", \"yw\", \"zw\"].forEach((props) => {\n\tpermutations(props.split(\"\")).forEach((combo) => {\n\t\taliasCombos.push(combo);\n\t});\n});\n\n/**\n * Util function to help generate permutations of property alias sets\n * @private\n */\nfunction permutations(list) {\n\t// Empty list has one permutation\n\tif (list.length === 0) return [[]];\n\tvar result = [];\n\tfor (var i=0; i<list.length; i++) {\n\t\tvar copy = list.slice();\n\t\tvar head = copy.splice(i, 1);\n\t\tvar rest = permutations(copy);\n\t\tfor (var j=0; j<rest.length; j++) {\n\t\t\tvar next = head.concat(rest[j]);\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\treturn result;\n}\n/**\n * @private\n */\nfunction getAliasCombo(combo) {\n\treturn combo.map((p) => this[p]);\n}\n\n/**\n * Adds x,y,z,w aliases to a quaternion.\n * @private\n */\nfunction defineAliases(q) {\n\tObject.defineProperties(q, {\n\t\tx:{get:function() {return this[0]}},\n\t\ty:{get:function() {return this[1]}},\n\t\tz:{get:function() {return this[2]}},\n\t\tw:{get:function() {return this[3]}}\n\t});\n\tfor(let i = 0, len = aliasCombos.length; i < len; ++i) {\n\t\tObject.defineProperty(q, aliasCombos[i].join(\"\"), {\n\t\t\tget:getAliasCombo.bind(q, aliasCombos[i])\n\t\t});\n\t}\n}\n\n/**\n * Create a string representation of a quaternion.\n * @example\n * // functional style\n * quaternions.quatToString(quaternions.create()); // quaternion(0.00, 0.00, 0.00, 1.00)\n * // OO style\n * quaternions.create().toString(); // quaternion(0.00, 0.00, 0.00, 1.00)\n * @param {quaternion} a quaternion to stringify\n * @return {string}\n */\nexport function toString(a) {\n\tlet strings = matrices.toArray(a).map((cur) => cur.toFixed(2));\n\treturn \"quaternion(\"+strings.join(\", \")+\")\";\n}\n\n/**\n * Performs a spherical linear interpolation between a and b.\n * @example\n * let q1 = quaternions.create([0.3,-0.6,-0.4,0.2]);\n * let q2 = quaternions.create([0.6,0.8,0.5,0.7]);\n * slerp(q1, q2, 0.4); // quaternion(0.75, 0.01, -0.02, 0.72);\n * @param {quaternion|array(4)} a origin quaternion\n * @param {quaternion|array(4)} b destination quaternion\n * @param {float} t interval [0...1]\n * @return {quaternion}\n */ \nexport const slerp = (function() {\n\tlet ax = 0.0, bx = 0.0, ay = 0.0, by = 0.0,\n\t\t  az = 0.0, bz = 0.0, aw = 0.0, bw = 0.0,\n\t\t\tcosHalfTheta = 0.0, sinHalfTheta = 0.0,\n\t\t\thalfTheta = 0.0,\n\t\t\tratioA = 0.0, ratioB = 0.0;\n\treturn function slerp(a, b, t, out = undefined) {\n\t\tax = a[0];\n\t\tbx = b[0];\n\t\tay = a[1];\n\t\tby = b[1];\n\t\taz = a[2];\n\t\tbz = b[2];\n\t\taw = a[3];\n\t\tbw = b[3];\n\t\tcosHalfTheta = ax * bx + ay * by + az * bz + aw * bw;\n\t\tout = out||create();\n\t\tif (abs(cosHalfTheta) >= 1.0) {\n\t\t\tout[0] = ax;\n\t\t\tout[1] = ay;\n\t\t\tout[2] = az;\n\t\t\tout[3] = aw;\n\t\t\treturn out;\n\t\t}\n\t\thalfTheta = acos(cosHalfTheta);\n\t\tsinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\t\tratioA = sin((1 - t) * halfTheta) / sinHalfTheta;\n\t\tratioB = sin(t * halfTheta) / sinHalfTheta;\n\n\t\tout[0] = ax * ratioA + bx * ratioB;\n\t\tout[1] = ay * ratioA + by * ratioB;\n\t\tout[2] = az * ratioA + bz * ratioB;\n\t\tout[3] = aw * ratioA + bw * ratioB;\n\t\treturn out;\n\t}\n})();\n\n/**\n * Normalize a quaternion.\n * @example\n * // functional style\n * quaternions.normalize([4.0, 10.0, 3.0, 1.0]).toString(); // quaternion(0.36, 0.89, 0.27, 0.09);\n * // OO style\n * quaternions.create([4.0, 10.0, 3.0, 1.0]).normalize(); // quaternion(0.36, 0.89, 0.27, 0.09);\n * @param {quaternion|array(4)} a quaternion to normalize\n * @param {quaternion} out (optional) out parameter\n * @return {quaternion}\n */\nexport function normalize(a, out = undefined) {\n\t// this function only exists to override the out parameter, so pass down\n\t// to the vector version of normalize afterward\n\tout = out||create();\n\tlet out2 = vecNrm(a, out);\n\treturn out2;\n}\n\n/**\n * Finds the inverse of a quaternion by normalizing then inverting the quat. Normalization\n * can be skipped by setting normalize = false if the quat is known to be normal already.\n * Be careful, since floating point errors will often de-normalize your quats!\n * @example\n * // functional\n * quaternions.invert([4.0,7.0,5.0,1.0]); // quaternion(-0.36, -0.89, -0.27, 0.09)\n * // OO\n * quaternions.create([4.0,7.0,5.0,1.0]).invert(); // quaternion(-0.36, -0.89, -0.27, 0.09)\n * @param {quaternion|array(4)} a the input quaternion\n * @param {quaternion} (optional) out out parameter\n * @param {bool} norm (default true) whether to normalize the quaternion before inverting\n * @return {quaternion}\n */\nexport const invert = (function() {\n\treturn function invert(a, norm = true, out = undefined) {\n\t\tout = out||create();\n\t\tif(norm) normalize(a, out);\n\t\telse out.set(a);\n\t\tout[0] = -out[0];\n\t\tout[1] = -out[1];\n\t\tout[2] = -out[2];\n\t\treturn out;\n\t}\n})();\n\n/**\n * Factory for creating quaternions. Quaternions are represented as 4 member arrays\n * of (x,y,z,w) where x,y,z are the vector component and w is the scalar component.\n * @example\n * quaternions.create([0.4, 32.1, 9.0, 1.0]); // quaternion(0.40, 32.10, 9.00, 1.00)\n * @param {array(4)} vals [x,y,z,w] (default [0,0,0,1] = identity quaternion)\n * @param {ArrayBuffer} buffer (optional) an array buffer to create the vector on \n * @param {offset} offset (optional) offset for the buffer, ignored if buffer is not supplied \n\n * @return {quaternion}\n */\nexport function create() {\n\tlet identity = [0,0,0,1];\n\tlet params = Array.prototype.slice.apply(arguments), len = params.length;\n\tif(len === 0) { // just create an identity quaternion \n\t\tparams = identity;\n\t}\n\telse {\n\t\tif(params[len-1] instanceof ArrayBuffer) { // supplied buffer, no offset\n\t\t\tif(len === 1) params = identity.concat(params).concat([0]);\n\t\t\telse params = params.concat([0]);\n\t\t}\n\t\telse if(params[len-2] instanceof ArrayBuffer) { // supplied buffer + offset\n\t\t\tif(len === 2) params = identity.concat(params);\n\t\t}\n\t}\n\tlet q = vectors.create.apply(null, [4].concat(params));\n\treturn q;\n}\n\n/**\n * Wraps a quaternion with aliases and quaternion functions as methods.\n * @param {quaternion} q quaternion to wrap\n * @return {quaternion} wrapped quaternion\n */\nexport function wrap(q) {\n\tdefineAliases(q);\n\tmatrices.wrap(q);\n\tq.slerp = asMethod(slerp, q);\n\tq.normalize = asMethod(normalize, q);\n\tq.invert = asMethod(invert, q);\n\tq.toString = toString.bind(null, q);\n\tq.times = asMethod(vectors.times, q);\n\tq.clamp = asMethod(vectors.clamp, q);\n\tq.normalize = asMethod(vectors.normalize, q);\n\tq.mut_normalize = asMethod(vectors.mut_normalize, q);\n\tq.mut_times = asMethod(vectors.mut_times, q);\n\tq.mut_clamp = asMethod(vectors.mut_clamp, q);\n\tq.mut_copy = asMethod(vectors.mut_copy, q);\n\treturn q;\n}\n\n/**\n * Turns a quaternion function into a method by wrapping its result.\n * @param {function} method\n * @param {quaternion} q \n * @private\n */\nfunction asMethod(method, q) {\n\treturn function() {\n\t\tlet res = method.apply(null, [q].concat(Array.prototype.slice.apply(arguments)));\n\t\treturn wrap(create(res));\n\t}\n}\n\n/**\n * Creates an identity quaternion [0,0,0,1].\n * @example \n * quaternions.create.identity(); // quaternion(0.00, 0.00, 0.00, 1.00)\n * @param {ArrayBuffer} buffer (optional) an array buffer to create the vector on \n * @param {offset} offset (optional) offset for the buffer, ignored if buffer is not supplied \n * @return {quaternion}\n */\ncreate.identity = function() {\n\treturn create();\n}\n\n/**\n * Creates a quaternion from Euler angles (in radians).\n * @example\n * quaternions.create.fromEulerAngles([75*Math.PI/180, 65*Math.PI/180, 15*Math.PI/180]); // quaternion(0.412, 0.56, 0.36, 0.62)\n * @param {array(3)} a [yaw,pitch,roll] in radians \n * @param {ArrayBuffer} buffer (optional) an array buffer to create the vector on \n * @param {offset} offset (optional) offset for the buffer, ignored if buffer is not supplied \n * @return {quaternion}\n */\ncreate.fromEulerAngles = (function() {\n\tlet yawh = 0.0, pitchh = 0.0, rollh = 0.0, c1 = 0.0, s1 = 0.0,\n\t\tc2 = 0.0, s2 = 0.0, c3 = 0.0, s3 = 0.0, c1c2 = 0.0, s1s2 = 0.0;\n\treturn function(a, buffer = undefined, offset = undefined) {\n\t\tlet out = create(buffer, offset);\n\t\tyawh = a[0]/2;\n\t\tpitchh = a[1]/2;\n\t\trollh = a[2]/2;\n\t\tc1 = cos(yawh);\n\t\ts1 = sin(yawh);\n\t\tc2 = cos(pitchh);\n\t\ts2 = sin(pitchh);\n\t\tc3 = cos(rollh);\n\t\ts3 = sin(rollh);\n\t\tc1c2 = c1*c2;\n\t\ts1s2 = s1*s2;\n\t\tout[0] = c1c2*s3 + s1s2*c3;\n\t\tout[1] = s1*c2*c3 + c1*s2*s3;\n\t\tout[2] = c1*s2*c3 - s1*c2*s3;\n\t\tout[3] = c1c2*c3 - s1s2*s3;\n\t\treturn out;\n\t}\n})();\n\n/**\n * Creates a quaternion from an axis-angle rotation.\n * @example\n * quaternions.create.fromAxisAngle([1,0,0],90*Math.PI/180); // quaternion(0.70, 0.00, 0.00, 0.70)\n * @param {array(3)} axis of rotation\n * @param {float} angle of rotation as radian\n * @param {ArrayBuffer} buffer (optional) an array buffer to create the vector on \n * @param {offset} offset (optional) offset for the buffer, ignored if buffer is not supplied \n * @return {quaternion}\n */\ncreate.fromAxisAngle = (function() {\n\tlet a = 0.0, angleh = 0.0;\n\treturn function fromAxisAngle(axis, angle, buffer = undefined, offset = undefined) {\n\t\tlet out = create(buffer, offset);\n\t\ta = vecNrm(axis);\n\t\tangleh = angle/2;\n\t\tout[0] = a[0] * sin(angleh);\n\t\tout[1] = a[1] * sin(angleh);\n\t\tout[2] = a[2] * sin(angleh);\n\t\tout[3] = cos(angleh);\n\t\treturn out;\n\t}\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nphyx-vectrix/src/vectrix.quaternions.js\n// module id = 34\n// module chunks = 0","/**\n * Derived from bokeh generator by Jack Rugile at [CodePen](http://codepen.io/jackrugile/pen/gaFub)\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.init = init;\nexports.generateBackground = generateBackground;\nexports.draw = draw;\n\nvar _photonomixUtil = require(\"../photonomix.util.js\");\n\nvar bgBuffer = void 0,\n    bokehBuffer = void 0,\n    bgCtx = void 0,\n    bokehCtx = void 0,\n    tau = Math.PI * 2,\n    parts = [],\n    displayProps = void 0;\n\nfunction rand(min, max) {\n\treturn Math.random() * (max - min) + min;\n}\n\nfunction hsla(h, s, l, a) {\n\treturn \"hsla(\" + h + \",\" + s + \"%,\" + l + \"%,\" + a + \")\";\n}\n\nfunction init(display) {\n\tdisplayProps = display.props;\n\tbgBuffer = display.buffersByLabel.bokehBack; //buffer1;\n\tbgCtx = bgBuffer.context;\n\tbokehBuffer = display.buffersByLabel.bokehFront; //buffer2;\n\tbokehCtx = bokehBuffer.context;\n\n\tvar sizeBase = bgBuffer.width + bgBuffer.height;\n\tvar w = bokehBuffer.width;\n\tvar h = bokehBuffer.height;\n\n\tparts.length = 0;\n\tfor (var i = 0; i < Math.floor((w + h) * 0.01); i++) {\n\t\tparts.push({\n\t\t\tradius: rand(sizeBase * 0.005, sizeBase * 0.02),\n\t\t\tx: rand(0, w),\n\t\t\ty: rand(0, h),\n\t\t\tangle: rand(0, tau),\n\t\t\tvel: rand(0.05, 0.2),\n\t\t\ttick: rand(0, 10000)\n\t\t});\n\t}\n\n\tgenerateBackground();\n\tdisplayProps.events.on(\"resize\", generateBackground);\n}\n\nfunction generateBackground() {\n\tvar w = bokehBuffer.width;\n\tvar h = bokehBuffer.height;\n\tvar mind = Math.min(w, h);\n\tvar maxd = Math.max(w, h);\n\tbgCtx.fillStyle = \"black\";\n\tbgCtx.fillRect(0, 0, w, h);\n\tvar g = bgCtx.createLinearGradient(0, 0, w, h);\n\tvar colors = [\"rgba(255,64,64,1.0)\", \"rgba(64,255,64,1.0)\", \"rgba(64,64,255,1.0)\"];\n\t(0, _photonomixUtil.shuffle)(colors);\n\tg.addColorStop(0.0, colors[0]);\n\tg.addColorStop(0.5, colors[1]);\n\tg.addColorStop(1.0, colors[2]);\n\tbgCtx.fillStyle = g;\n\tbgCtx.fillRect(0, 0, w, h);\n\tg = bgCtx.createLinearGradient(0, h, w, 0);\n\tcolors = [\"rgba(255,64,64,0.8)\", \"rgba(64,255,64,0.8)\", \"rgba(64,64,255,0.8)\"];\n\t(0, _photonomixUtil.shuffle)(colors);\n\tg.addColorStop(0.0, colors[0]);\n\tg.addColorStop(0.5, colors[1]);\n\tg.addColorStop(1.0, colors[2]);\n\tbgCtx.fillStyle = g;\n\tbgCtx.fillRect(0, 0, w, h);\n\n\tg = bgCtx.createRadialGradient(w / 2, h / 2, maxd / 2, w / 2, h / 2, 0);\n\tvar rad = (maxd - mind) / maxd;\n\tconsole.log(rad);\n\tg.addColorStop(1, \"rgba(64,64,64,0.6)\");\n\tg.addColorStop(rad + 0.06, \"rgba(0,0,0,0.8)\");\n\tg.addColorStop(rad + 0.05, \"rgba(128,128,128,1.0)\");\n\tg.addColorStop(rad + 0.04, \"rgba(255,255,255,0.6)\");\n\tg.addColorStop(rad + 0.03, \"rgba(255,255,255,0.8)\");\n\tg.addColorStop(rad + 0.025, \"rgba(255,255,255,0.8)\");\n\tg.addColorStop(rad + 0.005, \"rgba(255,255,255,0.5)\");\n\t/*\n g.addColorStop(rad + 0.07, \"rgba(0,0,0,0.8)\");\n g.addColorStop(rad + 0.085, \"rgba(128,128,128,1.0)\");\n g.addColorStop(rad + 0.10, \"rgba(255,255,255,0.6)\");\n g.addColorStop(rad + 0.11, \"rgba(255,255,255,0.8)\");\n g.addColorStop(rad + 0.13, \"rgba(255,255,255,0.8)\");\n g.addColorStop(rad + 0.16, \"rgba(255,255,255,0.5)\");\n */\n\tg.addColorStop(0, \"rgba(255,255,255,0.01)\");\n\tbgCtx.fillStyle = g;\n\tbgCtx.globalCompositeOperation = \"luminosity\";\n\tbgCtx.fillRect(0, 0, w, h);\n\tbgCtx.globalCompositeOperation = \"source-in\";\n}\n\nfunction draw() {\n\tvar i = parts.length;\n\tvar w = bokehBuffer.width;\n\tvar h = bokehBuffer.height;\n\tbokehCtx.fillStyle = \"rgba(0,0,0,0)\";\n\tbokehCtx.globalCompositeOperation = \"source-over\";\n\tbokehCtx.clearRect(0, 0, w, h);\n\tbokehCtx.shadowBlur = 15;\n\tbokehCtx.shadowColor = \"#fff\";\n\twhile (i--) {\n\t\tvar part = parts[i];\n\n\t\tpart.x += Math.cos(part.angle) * part.vel;\n\t\tpart.y += Math.sin(part.angle) * part.vel;\n\t\tpart.angle += rand(-0.05, 0.05);\n\n\t\tbokehCtx.beginPath();\n\t\tbokehCtx.arc(part.x, part.y, part.radius, 0, tau);\n\t\tbokehCtx.fillStyle = hsla(0, 0, 100, 0.03 + Math.cos(part.tick * 0.02) * 0.01);\n\t\tbokehCtx.fill();\n\n\t\tif (part.x - part.radius > w) part.x = -part.radius;\n\t\tif (part.x + part.radius < 0) part.x = w + part.radius;\n\t\tif (part.y - part.radius > h) part.y = -part.radius;\n\t\tif (part.y + part.radius < 0) part.y = h + part.radius;\n\n\t\tpart.tick++;\n\t}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/draw/bokeh.js\n// module id = 35\n// module chunks = 0","\"use strict\";\n/**\n * Module for drawing entity layer.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.draw = exports.init = undefined;\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _sprites = require(\"./sprites\");\n\nvar sprites = _interopRequireWildcard(_sprites);\n\nvar _photonomix = require(\"../photonomix.constants\");\n\nvar constants = _interopRequireWildcard(_photonomix);\n\nvar _photonomix2 = require(\"../photonomix.util\");\n\nvar _ = require(\"./\");\n\nvar _game = require(\"../game\");\n\nvar _Photon = require(\"../game/Photon\");\n\nvar _Mote = require(\"../game/Mote\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    lerp = _vectrix$vectors.lerp;\nvar mut_plus = vectrix.matrices.mut_plus;\nvar min = Math.min,\n    cos = Math.cos,\n    sin = Math.sin,\n    sqrt = Math.sqrt,\n    tan = Math.tan,\n    round = Math.round,\n    PI = Math.PI;\n\nvar tf = constants.TARGET_FPS;\n\nvar lightBuffer = void 0,\n    darkBuffer = void 0,\n    lightCtx = void 0,\n    darkCtx = void 0,\n    frameCount = void 0,\n    timing = void 0,\n    displayProps = void 0;\n\nvar voidSprite = void 0,\n    emitterSprite = void 0,\n    moteCenterSprite = void 0,\n    photonSprites = Array(3),\n    mask = void 0;\n\n/**\n * Draws plasma lines between a mote and its target.\n */\nvar drawPlasmaLine = function () {\n\tvar a = vec2(),\n\t    b = vec2(),\n\t    c = vec2(),\n\t    d = vec2(),\n\t    ra = vec2(),\n\t    rb = vec2(),\n\t    rax = 0 | 0,\n\t    ray = 0 | 0,\n\t    speeda = 0.0,\n\t    ta = 0.0,\n\t    tc = 0.0,\n\t    rbx = 0 | 0,\n\t    rby = 0 | 0,\n\t    speedb = 0.0,\n\t    tb = 0.0,\n\t    td = 0.0,\n\t    sx = 0 | 0,\n\t    sy = 0 | 0,\n\t    tx = 0 | 0,\n\t    ty = 0 | 0;\n\treturn function drawPlasmaLine(ctx, source, target, outerColor, innerColor) {\n\t\tvar lineSize = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n\t\tvar frameOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n\t\t// only these acts get lines\n\t\tta = 0.6;\n\t\ttc = 0.9;\n\t\ttb = 0.7;\n\t\ttd = 0.9;\n\t\tspeeda = 0.57121;\n\t\tspeedb = 0.71213;\n\t\tlerp(source, target, ta, a);\n\t\tlerp(source, target, tb, b);\n\t\tlerp(source, target, tc, c);\n\t\tlerp(source, target, td, d);\n\n\t\tmut_plus((0, _photonomix2.rotate)(a, c, tan(cos((frameCount + frameOffset) * speeda)), ra), a);\n\t\tmut_plus((0, _photonomix2.rotate)(b, d, tan(sin((frameCount + frameOffset) * speedb)), rb), b);\n\n\t\tsx = source[0];sy = source[1];\n\t\ttx = target[0];ty = target[1];\n\t\trax = ra[0];ray = ra[1];\n\t\trbx = rb[0];rby = rb[1];\n\t\tif (lightBuffer.width > lightBuffer.height) {\n\t\t\tsx = sx;\n\t\t\ttx = tx;\n\t\t\trax = rax;\n\t\t\trbx = rbx;\n\t\t} else {\n\t\t\tsy = sy;\n\t\t\tty = ty;\n\t\t\tray = ray;\n\t\t\trby = rby;\n\t\t}\n\t\tctx.beginPath();\n\t\tctx.moveTo(sx, sy);\n\t\tctx.bezierCurveTo(rax, ray, rbx, rby, tx, ty);\n\t\tctx.strokeStyle = outerColor;\n\t\tctx.lineWidth = round(cos((frameCount + frameOffset) * speeda) * lineSize);\n\t\tctx.lineCap = \"round\";\n\t\tctx.stroke();\n\t\tctx.closePath();\n\n\t\tctx.beginPath();\n\t\tctx.moveTo(sx, sy);\n\t\tctx.bezierCurveTo(rax, ray, rbx, rby, tx, ty);\n\t\tctx.strokeStyle = innerColor;\n\t\tctx.lineWidth = round(cos((frameCount + frameOffset) * speeda) * ~~(lineSize / 4));\n\t\tctx.lineCap = \"round\";\n\t\tctx.stroke();\n\t\tctx.closePath();\n\t};\n}();\n\n/**\n * Draw a mote.\n */\nvar drawMote = function () {\n\tvar pulse = 0 | 0,\n\t    pregnant = 0 | 0,\n\t    injured = 0 | 0,\n\t    lastMeal = 0 | 0,\n\t    size = 0.0,\n\t    plasmaSource = vec2(),\n\t    plasmaTarget = vec2(),\n\t    sc = 0.0,\n\t    sw = 0.0,\n\t    sch = 0.0,\n\t    swh = 0.0,\n\t    colorIndex = 0 | 0,\n\t    px = 0.0,\n\t    py = 0.0,\n\t    sprite = void 0;\n\treturn function drawMote(entity) {\n\t\tlightCtx.globalCompositeOperation = \"lighter\";\n\t\tpx = (0, _.screenSpace)(entity.pos[0]);\n\t\tpy = (0, _.screenSpace)(entity.pos[1]);\n\n\t\tpulse = entity.pulse;\n\t\tpregnant = entity.pregnant;\n\t\tinjured = entity.injured;\n\t\tlastMeal = entity.lastMeal;\n\n\t\tsize = entity.size * displayProps.minDimension;\n\t\tif (pregnant) {\n\t\t\tsc = size * cos((frameCount + pulse) * 0.2) * (sqrt(pregnant) + 1);\n\t\t\tsw = size * sin((frameCount + pulse + tf) * 0.2) * (sqrt(pregnant) + 1) * 0.1;\n\t\t} else if (injured) {\n\t\t\tsc = size * cos((frameCount + pulse) * (0.2 + (1 - 1 / injured)));\n\t\t\tsw = size * sin((frameCount + pulse + tf) * 0.2) * 0.1; //* (0.2+(1-1/injured)))*0.25;\n\t\t} else {\n\t\t\tsc = size * cos((frameCount + pulse) * 0.2);\n\t\t\tsw = size * sin((frameCount + pulse + tf) * 0.2) * 0.1;\n\t\t}\n\t\tsch = sc * 0.5;\n\t\tswh = sw * 0.5;\n\t\tcolorIndex = sprites.colorIndex(entity.color[_Photon.COLOR_R], entity.color[_Photon.COLOR_G], entity.color[_Photon.COLOR_B]);\n\t\tsprite = sprites.getMoteSprite(colorIndex);\n\t\tlightCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px - sch, py - sch, sc, sc);\n\t\tsprite = moteCenterSprite;\n\t\tlightCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px - sch, py - sch, sc, sc);\n\t\tif (entity.target && entity.action == _Mote.ACT_ATTACK) {\n\t\t\t// need vectors but in screen space, not absolute space\n\t\t\tplasmaSource[0] = px;\n\t\t\tplasmaSource[1] = py;\n\t\t\tplasmaTarget[0] = (0, _.screenSpace)(entity.target.pos[0]);\n\t\t\tplasmaTarget[1] = (0, _.screenSpace)(entity.target.pos[1]);\n\t\t\tdrawPlasmaLine(lightCtx, plasmaSource, plasmaTarget, sprites.getColorString(colorIndex), \"white\", 5, pulse);\n\t\t}\n\t};\n}();\n\n/**\n * Draws a photon.\n */\nvar drawPhoton = function () {\n\tvar sw = 0.0,\n\t    swh = 0.0,\n\t    px = 0.0,\n\t    py = 0.0,\n\t    ps = 0.0,\n\t    pulse = 0 | 0,\n\t    sprite = void 0;\n\treturn function drawPhoton(entity) {\n\t\t(0, _.updateCompositeOperation)(lightCtx, \"lighter\");\n\t\tpx = (0, _.screenSpace)(entity.pos[0]);\n\t\tpy = (0, _.screenSpace)(entity.pos[1]);\n\t\tsprite = photonSprites[entity.color];\n\t\tps = constants.PHOTON_BASE_SIZE * displayProps.minDimension; //sprite.pixelSize;\n\t\tpulse = entity.pulse;\n\t\tsw = ps * 0.75 * (cos((frameCount + pulse) * 0.3) * sin((frameCount + pulse) * 0.1)) + ps * 0.25;\n\t\tswh = sw * 0.5;\n\t\tlightCtx.drawImage(sprite.canvas, 0, 0, sprite.pixelSize, sprite.pixelSize, px - swh, py - swh, sw, sw);\n\t};\n}();\n\n/**\n * Draws a void.\n */\nvar drawVoid = function () {\n\tvar sc = 0.0,\n\t    sch = 0.0,\n\t    px = 0.0,\n\t    py = 0.0,\n\t    ox = 0.0,\n\t    oy = 0.0,\n\t    sprite = void 0,\n\t    sw = 0.0,\n\t    swh = 0.0,\n\t    colorIndex = 0 | 0;\n\treturn function drawVoid(entity) {\n\t\tpx = (0, _.screenSpace)(entity.pos[0]);\n\t\tpy = (0, _.screenSpace)(entity.pos[1]);\n\n\t\tsc = entity.size * displayProps.minDimension * 1 + sin(frameCount * 0.2);\n\t\tsch = sc * 0.5;\n\n\t\tsprite = voidSprite;\n\t\t(0, _.updateCompositeOperation)(darkCtx, \"source-over\");\n\t\tdarkCtx.drawImage(sprite.canvas, px - sch, py - sch, sc, sc);\n\t\tswitch (entity.lastMeal) {\n\t\t\tcase -1:\n\t\t\t\tcolorIndex = 0x888;break;\n\t\t\tcase _Photon.COLOR_R:\n\t\t\t\tcolorIndex = 0xf44;break;\n\t\t\tcase _Photon.COLOR_G:\n\t\t\t\tcolorIndex = 0x4f4;break;\n\t\t\tcase _Photon.COLOR_B:\n\t\t\t\tcolorIndex = 0x44f;break;\n\t\t}\n\t\t// white patch\n\t\tsw = sc * 1.7;\n\t\tswh = sw * 0.5;\n\t\tox = sin(frameCount * 0.0127) * sc * 0.1;\n\t\toy = cos(frameCount * 0.0127) * sc * 0.1;\n\t\tsprite = sprites.getMoteSprite(0xfff);\n\t\t(0, _.updateCompositeOperation)(darkCtx, \"soft-light\");\n\t\tdarkCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px + ox - swh, py + oy - swh, sw, sw);\n\t\t// color patch\n\t\tsw = sc * 1.2;\n\t\tswh = sw * 0.5;\n\t\tox = cos(frameCount * 0.023) * sc * 0.13;\n\t\toy = sin(frameCount * 0.023) * sc * 0.13;\n\t\tsprite = sprites.getMoteSprite(colorIndex);\n\t\tdarkCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px + ox - swh, py + oy - swh, sw, sw);\n\t\t// dark patch\n\t\tsprite = sprites.getMoteSprite(0x000);\n\t\tsw = sc * 1.65;\n\t\tswh = sw * 0.5;\n\t\tox = sin(frameCount * 0.0122) * sc * 0.15;\n\t\toy = cos(frameCount * 0.0122) * sc * 0.15;\n\t\t(0, _.updateCompositeOperation)(darkCtx, \"multiply\");\n\t\tdarkCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px + ox - swh, py + oy - swh, sw, sw);\n\t};\n}();\n\n/**\n * Draws an emitter.\n */\nvar drawEmitter = function () {\n\tvar sc = 0.0,\n\t    sch = 0.0,\n\t    px = 0.0,\n\t    py = 0.0,\n\t    ox = 0.0,\n\t    oy = 0.0,\n\t    sprite = void 0,\n\t    sw = 0.0,\n\t    swh = 0.0;\n\treturn function drawEmitter(entity) {\n\t\t(0, _.updateCompositeOperation)(lightCtx, \"lighter\");\n\t\tpx = (0, _.screenSpace)(entity.pos[0]);\n\t\tpy = (0, _.screenSpace)(entity.pos[1]);\n\n\t\tsc = entity.size * displayProps.minDimension;\n\t\t//sc = sc + (sc*(sin(frameCount*0.05))/100);\n\t\tsch = sc * 0.5;\n\n\t\tsprite = emitterSprite;\n\t\tlightCtx.drawImage(sprite.canvas, px - sch, py - sch, sc, sc);\n\n\t\tsw = cos(frameCount * 0.2) * sc * 1.7;\n\t\tswh = sw * 0.5;\n\n\t\tsprite = sprites.getMoteSprite(0x333);\n\t\tlightCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px - swh, py - swh, sw, sw);\n\n\t\tsw = sc * 1.3;\n\t\tswh = sw * 0.5;\n\t\tox = sin(frameCount * 0.08) * sc * 0.1;\n\t\toy = cos(frameCount * 0.08) * sc * 0.1;\n\t\tsprite = sprites.getMoteSprite(0x500);\n\t\tlightCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px + ox - swh, py + oy - swh, sw, sw);\n\n\t\tox = sin(frameCount * 0.08 + 2.094394) * sc * 0.1;\n\t\toy = cos(frameCount * 0.08 + 2.094394) * sc * 0.1;\n\t\tsprite = sprites.getMoteSprite(0x050);\n\t\tlightCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px + ox - swh, py + oy - swh, sw, sw);\n\n\t\tox = sin(frameCount * 0.08 + 4.188789) * sc * 0.1;\n\t\toy = cos(frameCount * 0.08 + 4.188789) * sc * 0.1;\n\t\tsprite = sprites.getMoteSprite(0x005);\n\t\tlightCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px + ox - swh, py + oy - swh, sw, sw);\n\t};\n}();\n\n/**\n * Draws an antigraviton cluster.\n */\nvar drawAntiGravitonCluster = function () {\n\tvar size = 0.0,\n\t    plasmaSource = vec2(),\n\t    plasmaTarget = vec2(),\n\t    lw = 4,\n\t    outerColor = \"rgba(0,0,0,0.3)\",\n\t    innerColor = \"rgba(0,0,0,0.7)\",\n\t    pi3rd = PI * (1 / 3),\n\t    px = 0.0,\n\t    py = 0.0,\n\t    ox = 0.0,\n\t    oy = 0.0,\n\t    sc = 0.0,\n\t    sch = 0.0,\n\t    sprite = void 0;\n\tfunction drawAntiPlasma(offset, length) {\n\t\tox = sin(frameCount * 0.08 + offset) * sc * length;\n\t\toy = cos(frameCount * 0.08 + offset) * sc * length;\n\t\tplasmaTarget[0] = px + ox;\n\t\tplasmaTarget[1] = py + oy;\n\t\tdrawPlasmaLine(darkCtx, plasmaSource, plasmaTarget, outerColor, innerColor, lw);\n\t}\n\treturn function drawAntiGravitonCluster(entity) {\n\t\t(0, _.updateCompositeOperation)(darkCtx, \"multiply\");\n\t\tpx = (0, _.screenSpace)(entity.pos[0]);\n\t\tpy = (0, _.screenSpace)(entity.pos[1]);\n\n\t\tsize = entity.size * displayProps.minDimension;\n\t\tsc = size;\n\t\tlw = min(4, ~~(sc / 2));\n\t\tsch = sc * 0.5;\n\t\tplasmaSource[0] = px;\n\t\tplasmaSource[1] = py;\n\n\t\tdrawAntiPlasma(0, 0.5);\n\t\tdrawAntiPlasma(pi3rd * 2, 0.5);\n\t\tdrawAntiPlasma(pi3rd * 4, 0.5);\n\t\tdrawAntiPlasma(pi3rd, 0.25);\n\t\tdrawAntiPlasma(pi3rd * 3, 0.25);\n\t\tdrawAntiPlasma(pi3rd * 5, 0.25);\n\n\t\tsprite = sprites.getMoteSprite(0x000);\n\t\tdarkCtx.drawImage(sprite.canvas, sprite.sx, sprite.sy, sprite.sw, sprite.sh, px - sch, py - sch, sc, sc);\n\t};\n}();\n\nvar init = exports.init = function init(display) {\n\tdisplayProps = display.props;\n\ttiming = display.timing;\n\tlightBuffer = display.buffersByLabel.entitiesLight;\n\tdarkBuffer = display.buffersByLabel.entitiesDark;\n\tlightCtx = lightBuffer.context;\n\tdarkCtx = darkBuffer.context;\n\tupdateProps();\n\tdisplayProps.events.on(\"resize\", updateProps);\n\tvoidSprite = sprites.createVoidSprite(1000, 1);\n\temitterSprite = sprites.createEmitterSprite(displayProps.minDimension, 1);\n\tphotonSprites[_Photon.COLOR_R] = sprites.createPhotonSprite(displayProps.minDimension, constants.PHOTON_BASE_SIZE, \"red\");\n\tphotonSprites[_Photon.COLOR_G] = sprites.createPhotonSprite(displayProps.minDimension, constants.PHOTON_BASE_SIZE, \"green\");\n\tphotonSprites[_Photon.COLOR_B] = sprites.createPhotonSprite(displayProps.minDimension, constants.PHOTON_BASE_SIZE, \"blue\");\n\tsprites.initMoteSpriteSheet(1000, constants.MOTE_BASE_SIZE * 4);\n\tmask = sprites.createGameSpaceMask();\n\tmoteCenterSprite = sprites.createMoteCenterSprite();\n};\n\n/**\n * Draw call for all entities. Loops through game entities and draws them according\n * to kind and displayProps.\n */\nvar draw = exports.draw = function () {\n\t// these variables are shared by draw calls below\n\tvar i = void 0,\n\t    l = void 0,\n\t    entity = void 0,\n\t    px = void 0,\n\t    py = void 0;\n\tvar lightClearStyle = \"rgba(0,0,0,0.3)\";\n\tvar darkClearStyle = \"rgba(0,0,0,0.1)\";\n\n\treturn function draw(state) {\n\t\t(0, _.updateCompositeOperation)(lightCtx, \"source-over\");\n\t\tlightCtx.fillStyle = lightClearStyle;\n\t\tlightCtx.fillRect(0, 0, lightBuffer.width, lightBuffer.height);\n\t\t(0, _.updateCompositeOperation)(darkCtx, \"destination-out\");\n\t\tdarkCtx.fillStyle = darkClearStyle;\n\t\tdarkCtx.clearRect(0, 0, darkBuffer.width, darkBuffer.height);\n\t\tframeCount = timing.frameCount;\n\t\tfor (i = 0, l = state.entities.length; i < l; ++i) {\n\t\t\tentity = state.entities[i];\n\t\t\tpx = (0, _.screenSpace)(entity.pos[0]);\n\t\t\tpy = (0, _.screenSpace)(entity.pos[1]);\n\t\t\tif ((0, _.offscreen)(px, py)) continue;\n\t\t\tif (entity instanceof _game.Mote) drawMote(entity);else if (entity instanceof _game.Photon) drawPhoton(entity);else if (entity instanceof _game.Void) drawVoid(entity);else if (entity instanceof _game.Emitter) drawEmitter(entity);else if (entity instanceof _game.AntiGravitonCluster) drawAntiGravitonCluster(entity);\n\t\t}\n\t\t(0, _.updateCompositeOperation)(lightCtx, \"destination-out\");\n\t\tlightCtx.drawImage(mask.canvas, 0, 0, displayProps.minDimension, displayProps.minDimension);\n\t\t(0, _.updateCompositeOperation)(darkCtx, \"destination-out\");\n\t\tdarkCtx.drawImage(mask.canvas, 0, 0, displayProps.minDimension, displayProps.minDimension);\n\t};\n}();\n\nfunction updateProps() {\n\tvar _displayProps = displayProps,\n\t    width = _displayProps.width,\n\t    height = _displayProps.height,\n\t    minDimension = _displayProps.minDimension,\n\t    orientation = _displayProps.orientation;\n\n\tvar ox = void 0,\n\t    oy = void 0;\n\tlightBuffer.width = darkBuffer.width = minDimension;\n\tlightBuffer.height = darkBuffer.height = minDimension;\n\tif (orientation) {\n\t\tox = 0;\n\t\toy = (height - width) / 2;\n\t} else {\n\t\tox = (width - height) / 2;\n\t\toy = 0;\n\t}\n\tlightBuffer.offsetX = darkBuffer.offsetX = ox;\n\tlightBuffer.offsetY = darkBuffer.offsetY = oy;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/draw/entities.js\n// module id = 36\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.draw = draw;\nexports.init = init;\n\nvar _ = require(\"./\");\n\nvar _photonomix = require(\"../photonomix.constants\");\n\nvar _photonomix2 = require(\"../photonomix.controls\");\n\nvar controls = _interopRequireWildcard(_photonomix2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar max = Math.max;\n\n\nvar ctx = void 0,\n    uiBuffer = void 0;\nvar displayProps = void 0;\n\n/**\n * Creates debug markers on screen to show the center, top, left, bottom, right, topleft\n * and topright extremes of the main game area.\n */\nvar debugMarkers = function () {\n\tvar w = void 0,\n\t    h = void 0,\n\t    wh = void 0,\n\t    hh = void 0;\n\treturn function debugMarkers() {\n\t\tw = displayProps.width;\n\t\th = displayProps.height;\n\t\twh = w / 2;\n\t\thh = h / 2;\n\t\t(0, _.drawCircle)(ctx, 0, 0, 4, \"yellow\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, wh, 0, 4, \"orange\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, w, 0, 4, \"red\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, 0, hh, 4, \"white\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, wh, hh, 4, \"gray\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, w, hh, 4, \"black\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, 0, h, 4, \"blue\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, wh, h, 4, \"cyan\", 1, \"white\");\n\t\t(0, _.drawCircle)(ctx, w, h, 4, \"green\", 1, \"white\");\n\t};\n}();\n\n/**\n * Draws an edge button.\n */\nfunction drawEdgeButton(ctx, x, y, w, h) {\n\tvar halfButtonWidth = w * 0.5;\n\tvar buttonHeight = h;\n\tvar cpXScale = w * 0.122;\n\tvar beginX = x - halfButtonWidth;\n\tvar beginY = y;\n\tvar topX = x;\n\tvar topY = y - buttonHeight;\n\tvar endX = x + halfButtonWidth;\n\tvar endY = y;\n\tvar aCPX = beginX + cpXScale;\n\tvar aCPY = beginY - cpXScale;\n\tvar bCPX = beginX + cpXScale;\n\tvar bCPY = topY;\n\tvar cCPX = endX - cpXScale;\n\tvar cCPY = topY;\n\tvar dCPX = endX - cpXScale;\n\tvar dCPY = endY - cpXScale;\n\tvar color = \"rgba(255,255,255,0.1)\";\n\n\tctx.beginPath();\n\tctx.moveTo(beginX, beginY);\n\tctx.bezierCurveTo(aCPX, aCPY, bCPX, bCPY, topX, topY);\n\tctx.bezierCurveTo(cCPX, cCPY, dCPX, dCPY, endX, endY);\n\tctx.fillStyle = color;\n\tctx.strokeStyle = color;\n\tctx.lineWidth = 4;\n\tctx.fill();\n\tctx.closePath();\n}\n\n/**\n * Draws UI elements.\n */\nfunction draw() {\n\tvar w = displayProps.width;\n\tvar h = displayProps.height;\n\tvar bw = max(100, w * 0.1);\n\tvar bh = max(47, w * 0.047);\n\tvar _controls$pointer = controls.pointer,\n\t    move = _controls$pointer.move,\n\t    down = _controls$pointer.down;\n\n\tctx.clearRect(0, 0, w, h);\n\tdrawEdgeButton(ctx, w * 0.5, h, bw, bh);\n\tdrawEdgeButton(ctx, w * 0.333, h, bw, bh);\n\tdrawEdgeButton(ctx, w * 0.666, h, bw, bh);\n\t(0, _.drawCircle)(ctx, move[0], move[1], 5, \"white\");\n\tif (controls.buttons[0]) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(down[0], down[1]);\n\t\tctx.lineTo(move[0], move[1]);\n\t\tctx.strokeStyle = \"white\";\n\t\tctx.lineWidth = 2;\n\t\tctx.stroke();\n\t\tctx.closePath();\n\t}\n\t//drawAntiGravitonCluster(agClusterIcon, ctx);\n\tif (_photonomix.DEBUG) debugMarkers();\n}\n\n/**\n * Initializes the UI submodule.\n * @param {Object} display pxene display object initialized with a ui buffer\n */\nfunction init(display) {\n\tdisplayProps = display.props;\n\tuiBuffer = display.buffersByLabel.ui;\n\tupdateProps();\n\tdisplayProps.events.on(\"resize\", updateProps);\n\tctx = uiBuffer.context;\n}\n\nfunction updateProps() {\n\tuiBuffer.width = displayProps.width;\n\tuiBuffer.height = displayProps.height;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/draw/ui.js\n// module id = 37\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = AntiGravitonCluster;\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomix = require(\"../photonomix.util\");\n\nvar _ = require(\"./\");\n\nvar _photonomix2 = require(\"../photonomix.constants\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    times = _vectrix$vectors.times,\n    distance = _vectrix$vectors.distance,\n    mut_copy = _vectrix$vectors.mut_copy;\nvar mut_plus = vectrix.matrices.mut_plus;\nvar random = Math.random,\n    sqrt = Math.sqrt,\n    PI = Math.PI,\n    ceil = Math.ceil,\n    min = Math.min,\n    max = Math.max;\n\nvar POS_C = vec2(0, 0);\n\nfunction AntiGravitonCluster() {\n\tvar ipos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : vec2();\n\tvar ivel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vec2();\n\tvar mass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\tvar photonPool = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n\tthis.pos = vec2(ipos);\n\tthis.vel = vec2(ivel);\n\tthis.size = 0;\n\tthis.birthMass = this.initialMass = mass;\n\tthis.mass = 1;\n\tthis.photonPool = photonPool;\n\tthis.instability = 0;\n\tthis.size = 0;\n\treturn this;\n}\n\nvar scratch = vec2(),\n    entity = void 0,\n    i = 0 | 0,\n    len = 0 | 0,\n    dist = 0.0,\n    consume = 0 | 0;\nAntiGravitonCluster.prototype.tick = function (entities, delta, frameCount) {\n\tif (this.birthMass > 0) {\n\t\tconsume = min(this.birthMass, ceil(this.mass / 10));\n\t\tthis.birthMass -= consume;\n\t\tthis.mass += consume;\n\t}\n\tthis.size = sqrt(this.mass * 0.05 / PI) * _photonomix2.MOTE_BASE_SIZE;\n\t// last turn's move, has to happen first\n\tmut_plus(this.pos, times(this.vel, delta, scratch));\n\tthis.initialMass = max(this.mass, this.initialMass);\n\n\t// apply basic forces\n\t// don't go off the screen\n\tmut_plus(this.vel, (0, _photonomix.avoid)(this.vel, this.pos, POS_C, 1.3, 0.01, scratch));\n\t// apply drag\n\tmut_plus(this.vel, (0, _photonomix.drag)(this.vel, _photonomix2.GLOBAL_DRAG));\n\n\tif (this.birthMass === 0) {\n\t\tthis.instability += this.mass * 0.003;\n\t}\n\tif (frameCount % ceil(_photonomix2.TARGET_FPS * 0.05) === 0) {\n\t\twhile (this.instability > 0 && this.mass > 0) {\n\t\t\tentities.push(this.emitPhoton());\n\t\t\tthis.mass -= min(this.mass, 7);\n\t\t\tthis.instability -= 0.9;\n\t\t}\n\t}\n\n\tfor (i = 0, len = entities.length; i < len; ++i) {\n\t\tentity = entities[i];\n\t\tif (entity === this) continue;\n\t\tdist = distance(this.pos, entity.pos);\n\n\t\tif (entity instanceof _.Void) {\n\t\t\tif (dist < (entity.size + this.size) * 0.5) {\n\t\t\t\tconsume = min(entity.mass, ceil((entity.mass + entity.birthMass) / 10));\n\t\t\t\tthis.mass += consume;\n\t\t\t\tentity.mass -= consume;\n\t\t\t\tthis.instability += consume * 0.07;\n\t\t\t}\n\t\t\tif (dist < this.size * 10) mut_plus(this.vel, (0, _photonomix.accelerate)(this.pos, entity.pos, this.size * dist * 5, scratch));\n\t\t\treturn;\n\t\t}\n\t}\n};\n\nAntiGravitonCluster.prototype.emitPhoton = function () {\n\tvar pos = vec2(),\n\t    vel = vec2(),\n\t    rot = vec2(),\n\t    radians = 0.0,\n\t    mim = 0.0,\n\t    color = 0 | 0;\n\treturn function emitPhoton() {\n\t\tcolor = ~~(random() * 3);\n\t\tpos[0] = this.size * 0.1;\n\t\tpos[1] = this.size * 0.1;\n\t\tmut_plus(pos, this.pos);\n\t\tmut_copy(vel, this.vel);\n\t\tmim = this.mass % this.initialMass;\n\t\tradians = mim / (this.initialMass / 2);\n\t\tradians = radians + mim % 100 * (2 / 100); // split across arms\n\t\tmut_copy(rot, (0, _photonomix.rotate)(pos, this.pos, radians, pos));\n\t\tmut_plus(rot, this.pos);\n\t\tmut_plus(pos, rot);\n\t\t// introduce some jitter\n\t\tmut_plus(vel, (0, _photonomix.accelerate)(this.pos, pos, this.size * 2, scratch));\n\t\treturn new _.Photon(pos, vel, color, this.photonPool);\n\t};\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/game/AntiGravitonCluster.js\n// module id = 38\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = Emitter;\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nvar _photonomix = require(\"../photonomix.constants\");\n\nvar _photonomix2 = require(\"../photonomix.util\");\n\nvar _ = require(\"./\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _vectrix$vectors = vectrix.vectors,\n    vec2 = _vectrix$vectors.vec2,\n    times = _vectrix$vectors.times,\n    mut_times = _vectrix$vectors.mut_times,\n    distance = _vectrix$vectors.distance;\nvar mut_plus = vectrix.matrices.mut_plus;\nvar random = Math.random,\n    sqrt = Math.sqrt,\n    ceil = Math.ceil,\n    min = Math.min,\n    PI = Math.PI;\n\nvar POS_C = vec2(0, 0);\n\n/**\n * Emitters are \"white holes\" that spit out photons on a fixed schedule until depleted.\n */\nfunction Emitter() {\n\tvar ipos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : vec2();\n\tvar ivel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vec2();\n\tvar mass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\tvar photonPool = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\tvar arms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n\n\tthis.pos = vec2(ipos);\n\tthis.vel = vec2(ivel);\n\tthis.birthMass = mass;\n\tthis.mass = 1;\n\tthis.initialMass = mass;\n\tthis.photonPool = photonPool;\n\tthis.arms = arms || ceil(random() * random() * 50);\n\tthis.size = 0;\n\tthis.next = ~~(random() * 3);\n\treturn this;\n}\n\nvar scratchVec1 = vec2(),\n    emissionsPerSecond = 0 | 0,\n    emissionsPerFrame = 0 | 0,\n    targetFrame = 0 | 0,\n    i = 0 | 0,\n    len = 0 | 0,\n    entity = void 0,\n    a_dist = 0.0,\n    consume = 0 | 0;\nEmitter.prototype.tick = function (entities, delta, frameCount) {\n\t/* jshint unused:false */\n\tif (this.birthMass > 0) {\n\t\tconsume = min(this.birthMass, ceil(this.mass / 100));\n\t\tthis.birthMass -= consume;\n\t\tthis.mass += consume;\n\t}\n\tthis.size = sqrt(this.mass / PI) * _photonomix.EMITTER_SIZE;\n\tif (this.birthMass === 0) {\n\t\t// don't start producing until finished spawning\n\t\temissionsPerSecond = this.initialMass / 20;\n\t\ttargetFrame = ceil(_photonomix.TARGET_FPS / emissionsPerSecond);\n\t\temissionsPerFrame = emissionsPerSecond / _photonomix.TARGET_FPS;\n\t\tif (frameCount % targetFrame === 0) {\n\t\t\twhile (emissionsPerFrame-- > 0 && this.mass > 0) {\n\t\t\t\tthis.mass--;\n\t\t\t\tentities.push(this.emitPhoton());\n\t\t\t}\n\t\t}\n\t}\n\t// last turn's move, has to happen first\n\tmut_plus(this.pos, times(this.vel, delta, scratchVec1));\n\t// apply drag\n\tmut_plus(this.vel, (0, _photonomix2.drag)(this.vel, _photonomix.GLOBAL_DRAG));\n\t// avoid edge\n\tmut_plus(this.vel, (0, _photonomix2.avoid)(this.vel, this.pos, POS_C, 1.3, 0.001, scratchVec1));\n\n\tfor (i = 0, len = entities.length; i < len; ++i) {\n\t\tentity = entities[i];\n\t\tif (entity === this) continue;\n\t\ta_dist = distance(this.pos, entity.pos);\n\t\tif (entity instanceof Emitter) {\n\t\t\tmut_plus(entity.vel, mut_times((0, _photonomix2.gravitate)(entity.pos, this.pos, this.mass * entity.mass, scratchVec1), 1 / entity.mass));\n\t\t} else {\n\t\t\tmut_plus(entity.vel, mut_times((0, _photonomix2.gravitate)(entity.pos, this.pos, -this.mass * entity.mass, scratchVec1), 1 / entity.mass));\n\t\t}\n\t}\n};\n\nEmitter.prototype.emitPhoton = function () {\n\tvar pos = vec2(),\n\t    radians = 0.0,\n\t    mim = 0.0,\n\t    color = 0 | 0;\n\treturn function emitPhoton() {\n\t\tcolor = this.next;\n\t\tpos[0] = this.size / 5;\n\t\tpos[1] = this.size / 5;\n\t\tmut_plus(pos, this.pos);\n\t\tmim = this.mass % this.initialMass;\n\t\tradians = mim / (this.initialMass / 2);\n\t\tradians = radians + mim % this.arms * (2 / this.arms); // split across arms\n\t\tmut_plus((0, _photonomix2.rotate)(pos, this.pos, radians, pos), this.pos);\n\t\tthis.next = ~~(random() * 3);\n\t\t// introduce some jitter\n\t\treturn new _.Photon(pos, vec2(0, 0), color, this.photonPool);\n\t};\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/game/Emitter.js\n// module id = 39\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.MARKER_HIT = undefined;\nexports.default = Marker;\n\nvar _photonomix = require(\"../photonomix.constants\");\n\nvar _vectrix = require(\"@nphyx/vectrix\");\n\nvar vectrix = _interopRequireWildcard(_vectrix);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar MARKER_HIT = exports.MARKER_HIT = 0;\n\nfunction Marker(type, pos) {\n\tvar lifetime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _photonomix.TARGET_FPS;\n\n\tthis.type = type;\n\tthis.pos = vectrix.vectors.vec2(pos);\n\tthis.start = lifetime;\n\tthis.lifetime = lifetime;\n}\n\nMarker.prototype.tick = function () {\n\tthis.lifetime--;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/game/Marker.js\n// module id = 40\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.BufferPool = BufferPool;\nvar MAX_POOL_SIZE = exports.MAX_POOL_SIZE = Math.pow(2, 21); // 2mb\n\nfunction calculatePoolSize(itemLength) {\n\treturn MAX_POOL_SIZE - MAX_POOL_SIZE % itemLength;\n}\n\nfunction createFreedList(freedLength) {\n\tif (freedLength < Math.pow(2, 8)) return new Uint8Array(freedLength);else if (freedLength < Math.pow(2, 16)) return new Uint16Array(freedLength);else return new Uint32Array(freedLength);\n}\n\nfunction BufferPool(itemLength, maxItems) {\n\tvar size = 0 | 0;\n\tif (maxItems) {\n\t\tif (itemLength * maxItems > MAX_POOL_SIZE) {\n\t\t\tthrow new Error(\"requested buffer size is too large\");\n\t\t} else size = itemLength * maxItems;\n\t} else size = calculatePoolSize(itemLength);\n\tvar buffer = new ArrayBuffer(size);\n\tvar freedLength = maxItems ? maxItems : size / itemLength;\n\tvar freed = createFreedList(freedLength);\n\tObject.defineProperties(this, {\n\t\t\"itemLength\": { get: function get() {\n\t\t\t\treturn itemLength;\n\t\t\t} },\n\t\t\"buffer\": { get: function get() {\n\t\t\t\treturn buffer;\n\t\t\t} },\n\t\t\"size\": { get: function get() {\n\t\t\t\treturn size;\n\t\t\t} },\n\t\t\"freed\": { get: function get() {\n\t\t\t\treturn freed;\n\t\t\t} }\n\t});\n\tthis.next = 0;\n\tthis.freedPos = 0;\n\treturn this;\n}\n\nvar offset = 0 | 0;\nBufferPool.prototype.allocate = function () {\n\tif (this.freedPos > 0) offset = this.popFree();else if (this.next < this.size - 1) {\n\t\toffset = this.next;\n\t\tthis.next = this.next + this.itemLength;\n\t} else throw new Error(\"pool buffer is full\");\n\treturn offset;\n};\n\nBufferPool.prototype.popFree = function () {\n\tthis.freedPos--;\n\toffset = this.freed[this.freedPos] * this.itemLength;\n\tthis.freed[this.freedPos] = 0;\n\treturn offset;\n};\n\nBufferPool.prototype.free = function (offset) {\n\tthis.freed[this.freedPos] = offset === 0 ? offset : offset / this.itemLength;\n\tthis.freedPos++;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/photonomix.bufferPools.js\n// module id = 41\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Events = Events;\nfunction Events() {\n\tthis.queue = {};\n\treturn this;\n}\n\nEvents.prototype.on = function (event, callback) {\n\tif (this.queue[event] === undefined) this.queue[event] = [];\n\tthis.queue[event].push(callback);\n};\n\nEvents.prototype.fire = function () {\n\tvar i = void 0,\n\t    len = void 0;\n\treturn function (event, params) {\n\t\tif (this.queue[event] === undefined) return;\n\t\tfor (i = 0, len = this.queue[event].length; i < len; ++i) {\n\t\t\tthis.queue[event][i].call(params);\n\t\t}\n\t};\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/photonomix.events.js\n// module id = 42\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.startGame = startGame;\n\nvar _pxene = require(\"@nphyx/pxene\");\n\nvar _draw = require(\"./draw\");\n\nvar draw = _interopRequireWildcard(_draw);\n\nvar _game = require(\"./game\");\n\nvar game = _interopRequireWildcard(_game);\n\nvar _photonomix = require(\"./photonomix.constants\");\n\nvar constants = _interopRequireWildcard(_photonomix);\n\nvar _photonomix2 = require(\"./photonomix.util\");\n\nvar util = _interopRequireWildcard(_photonomix2);\n\nvar _photonomix3 = require(\"./photonomix.controls\");\n\nvar controls = _interopRequireWildcard(_photonomix3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar displayConfig = {\n\tcontainer: \"body\",\n\tbufferDescriptions: [{ label: \"bokehBack\", compositeMethod: \"source-over\", scaleMethod: _pxene.display.buffers.SCALE_KEEP_ASPECT }, { label: \"bokehFront\", compositeMethod: \"lighter\", scaleMethod: _pxene.display.buffers.SCALE_NONE }, { label: \"entitiesLight\", compositeMethod: \"lighter\", scaleMethod: _pxene.display.buffers.SCALE_NONE }, { label: \"entitiesDark\", compositeMethod: \"hard-light\", scaleMethod: _pxene.display.buffers.SCALE_NONE }, { label: \"ui\", compositeMethod: \"source-over\", scaleMethod: _pxene.display.buffers.SCALE_NONE }],\n\tpixelRatio: 1,\n\tframeCallback: main\n};\n\nvar photonomix = {\n\tutil: util,\n\tconstants: constants,\n\tdisplay: _pxene.display,\n\tgame: game,\n\tdraw: draw,\n\tstate: {}\n};\n\nwindow.photonomix = photonomix;\n\nwindow.addEventListener(\"load\", function () {\n\tphotonomix.state.game = new game.Game();\n\t_pxene.display.init(displayConfig);\n\tdraw.init(photonomix.state, _pxene.display);\n\tcontrols.init(photonomix.state);\n\tphotonomix.state.controls = controls.state;\n\tstartGame();\n});\n\nfunction main() {\n\t//let tickSpeed = display.timing.interval/display.timing.elapsed;\n\tif (photonomix.state.game.started) photonomix.state.game.tick(_pxene.display.timing);\n\tphotonomix.draw.tick();\n}\n\n/**\n * Starts up the game.\n */\nfunction startGame() {\n\tphotonomix.state.game.start();\n\t/*\n body.removeEventListener(\"click\", startGame);\n body.classList.remove(\"start\");\n if(AUTO_FULLSCREEN) toggleFullScreen();\n */\n\tconsole.log(\"game started\");\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./target/scripts/photonomix.js\n// module id = 43\n// module chunks = 0"],"sourceRoot":""}